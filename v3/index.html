<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Corrector mínimo</title>
  <style>
    :root {
      --bg: #fff;
      --fg: #111;
      --line: #d0d0d0;
      --line-strong: #b8b8b8;
      --panel: #f7f7f7;
      --muted: #666;
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", Arial, sans-serif;
      font-size: 16px;
      line-height: 1.5;
    }

    .app {
      height: 100vh;
      display: grid;
      grid-template-columns: 1fr 360px;
    }

    .editor-pane {
      border-right: 1px solid var(--line);
      min-width: 0;
    }

    .editor-wrap {
      position: relative;
      height: 100%;
      overflow: hidden;
    }

    .highlights,
    textarea {
      position: absolute;
      inset: 0;
      margin: 0;
      padding: 20px 24px;
      border: 0;
      resize: none;
      width: 100%;
      height: 100%;
      overflow: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: anywhere;
      line-height: 1.5;
      font: inherit;
      letter-spacing: inherit;
      tab-size: 2;
    }

    .highlights {
      pointer-events: none;
      color: transparent;
      background: var(--bg);
    }

    .mark {
      color: transparent;
      text-decoration-line: underline;
      text-decoration-color: var(--line-strong);
      text-decoration-thickness: 1px;
      text-underline-offset: 3px;
      text-decoration-skip-ink: none;
    }

    textarea {
      color: var(--fg);
      background: transparent;
      caret-color: var(--fg);
      outline: none;
    }

    textarea::selection,
    .highlights::selection {
      background: #e9e9e9;
    }

    .side {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: #fcfcfc;
    }

    .side-head {
      padding: 16px;
      border-bottom: 1px solid var(--line);
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: .05em;
      color: var(--muted);
    }

    .cards {
      flex: 1;
      overflow: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .card {
      border: 1px solid var(--line);
      background: var(--bg);
      padding: 12px;
      display: grid;
      gap: 8px;
    }

    .row {
      display: grid;
      gap: 3px;
    }

    .label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .04em;
    }

    .value {
      font-size: 15px;
      overflow-wrap: anywhere;
    }

    .actions {
      display: flex;
      gap: 8px;
      margin-top: 2px;
    }

    button {
      appearance: none;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--fg);
      font: inherit;
      font-size: 13px;
      padding: 6px 10px;
      cursor: pointer;
    }

    button:hover { border-color: #9f9f9f; }
    button:active { background: #ececec; }

    .empty {
      padding: 16px;
      border: 1px dashed var(--line);
      color: var(--muted);
      font-size: 14px;
      background: #fafafa;
    }

    @media (max-width: 940px) {
      .app { grid-template-columns: 1fr; }
      .editor-pane { border-right: 0; border-bottom: 1px solid var(--line); height: 62vh; }
      .side { height: 38vh; }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="editor-pane">
      <div class="editor-wrap">
        <pre class="highlights" id="highlights" aria-hidden="true"></pre>
        <textarea id="editor" spellcheck="false" placeholder="Escribe o pega texto aquí..."></textarea>
      </div>
    </section>

    <aside class="side">
      <div class="side-head">Sugerencias</div>
      <div class="cards" id="cards"></div>
    </aside>
  </main>

  <script>
    const editor = document.getElementById('editor');
    const highlights = document.getElementById('highlights');
    const cards = document.getElementById('cards');

    let stateText = '';
    let activeErrors = [];
    let dismissed = new Set();
    let analyzeSeq = 0;

    const debounce = (fn, delay = 120) => {
      let t = 0;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), delay);
      };
    };

    const escapeHtml = (s) => s
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');

    const stableId = (e) => `${e.type}|${e.from}|${e.to}|${e.original}|${e.suggestion}`;

    function normalizeApiErrors(text, errors) {
      return (Array.isArray(errors) ? errors : [])
        .map((e) => ({
          from: Number.isInteger(e.start) ? e.start : -1,
          to: Number.isInteger(e.end) ? e.end : -1,
          suggestion: typeof e.suggestion === 'string' ? e.suggestion : '',
          type: typeof e.type === 'string' ? e.type : 'grammar'
        }))
        .filter((e) => e.from >= 0 && e.to > e.from && e.to <= text.length)
        .sort((a, b) => a.from - b.from || a.to - b.to)
        .reduce((acc, e) => {
          const last = acc[acc.length - 1];
          if (!last || e.from >= last.to) {
            acc.push({
              ...e,
              original: text.slice(e.from, e.to)
            });
          }
          return acc;
        }, [])
        .map((e) => ({ ...e, id: stableId(e) }));
    }

    function renderHighlights(text, errors) {
      if (!errors.length) {
        highlights.innerHTML = `${escapeHtml(text)}\n`;
        return;
      }
      let html = '';
      let cursor = 0;
      for (const e of errors) {
        html += escapeHtml(text.slice(cursor, e.from));
        html += `<span class="mark">${escapeHtml(text.slice(e.from, e.to))}</span>`;
        cursor = e.to;
      }
      html += escapeHtml(text.slice(cursor));
      highlights.innerHTML = `${html}\n`;
    }

    function renderCards(errors, statusMessage = '') {
      if (statusMessage) {
        cards.innerHTML = `<div class="empty">${escapeHtml(statusMessage)}</div>`;
        return;
      }
      if (!errors.length) {
        cards.innerHTML = '<div class="empty">Sin sugerencias activas.</div>';
        return;
      }
      const frag = document.createDocumentFragment();
      for (const e of errors) {
        const card = document.createElement('article');
        card.className = 'card';
        card.innerHTML = `
          <div class="row"><span class="label">Fragmento</span><span class="value">${escapeHtml(e.original) || '∅'}</span></div>
          <div class="row"><span class="label">Sugerencia</span><span class="value">${escapeHtml(e.suggestion) || 'Eliminar'}</span></div>
          <div class="row"><span class="label">Tipo</span><span class="value">${escapeHtml(e.type)}</span></div>
          <div class="actions">
            <button data-action="accept" data-id="${e.id}">Aceptar</button>
            <button data-action="reject" data-id="${e.id}">Rechazar</button>
          </div>
        `;
        frag.appendChild(card);
      }
      cards.innerHTML = '';
      cards.appendChild(frag);
    }

    async function fetchCorrections(text, seq) {
      const response = await fetch('/api/correct', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });

      if (!response.ok || !response.body) {
        return { type: 'error', status: response.status || 500 };
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let pending = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        if (seq !== analyzeSeq) return { type: 'stale' };

        pending += decoder.decode(value, { stream: true });
        const events = pending.split('\n\n');
        pending = events.pop() || '';

        for (const block of events) {
          const dataLine = block.split('\n').find((line) => line.startsWith('data: '));
          if (!dataLine) continue;
          const payload = dataLine.slice(6).trim();
          if (!payload) continue;

          let parsed;
          try {
            parsed = JSON.parse(payload);
          } catch {
            continue;
          }

          if (parsed.type === 'error') {
            return { type: 'error', status: parsed.status || 500 };
          }

          if (parsed.type === 'result') {
            return { type: 'result', errors: parsed.errors || [] };
          }
        }
      }

      return { type: 'result', errors: [] };
    }

    const analyze = debounce(async () => {
      const text = editor.value;
      const changed = text !== stateText;
      stateText = text;
      if (changed) dismissed = new Set();

      const seq = ++analyzeSeq;
      renderHighlights(text, []);
      renderCards([], 'Analizando texto...');

      if (!text.trim()) {
        activeErrors = [];
        renderHighlights(text, activeErrors);
        renderCards(activeErrors);
        return;
      }

      try {
        const result = await fetchCorrections(text, seq);
        if (seq !== analyzeSeq || result.type === 'stale') return;

        if (result.type === 'error') {
          activeErrors = [];
          renderHighlights(text, activeErrors);
          renderCards([], `No se pudo analizar (OpenAI ${result.status}). Revisa tu API key.`);
          return;
        }

        const all = normalizeApiErrors(text, result.errors);
        activeErrors = all.filter((e) => !dismissed.has(e.id));
        renderHighlights(text, activeErrors);
        renderCards(activeErrors);
      } catch {
        if (seq !== analyzeSeq) return;
        activeErrors = [];
        renderHighlights(text, activeErrors);
        renderCards([], 'No se pudo analizar (OpenAI 500). Revisa tu API key.');
      }
    }, 120);

    function applyCorrection(id) {
      const target = activeErrors.find(e => e.id === id);
      if (!target) return;

      const before = editor.value;
      const selStart = editor.selectionStart;
      const selEnd = editor.selectionEnd;
      const next = before.slice(0, target.from) + target.suggestion + before.slice(target.to);
      const delta = target.suggestion.length - (target.to - target.from);

      let newStart = selStart;
      let newEnd = selEnd;

      if (selStart > target.to) newStart += delta;
      else if (selStart > target.from) newStart = target.from + target.suggestion.length;

      if (selEnd > target.to) newEnd += delta;
      else if (selEnd > target.from) newEnd = target.from + target.suggestion.length;

      stateText = next;
      editor.value = next;
      editor.setSelectionRange(newStart, newEnd);
      dismissed = new Set();
      analyze();
    }

    function rejectCorrection(id) {
      dismissed.add(id);
      activeErrors = activeErrors.filter(e => e.id !== id);
      renderHighlights(editor.value, activeErrors);
      renderCards(activeErrors);
    }

    editor.addEventListener('input', analyze, { passive: true });
    editor.addEventListener('scroll', () => {
      highlights.scrollTop = editor.scrollTop;
      highlights.scrollLeft = editor.scrollLeft;
    }, { passive: true });

    cards.addEventListener('click', (ev) => {
      const button = ev.target.closest('button[data-action]');
      if (!button) return;
      const { action, id } = button.dataset;
      if (action === 'accept') applyCorrection(id);
      if (action === 'reject') rejectCorrection(id);
    });

    editor.value = 'Este texto qeu tiene errores de puntuación , y palabras tambine mal escritas.';
    analyze();
    editor.focus();
  </script>


</body>
</html>
