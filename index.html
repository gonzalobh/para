<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>para — parafrasear texto</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html,
    body {
      height: 100%;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: linear-gradient(180deg, #ffffff 0%, #f9f9f9 100%);
      margin: 0;
      min-height: 100vh;
      color: #111;
    }

    .page {
      min-height: 100vh;
      padding: 40px;
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      min-height: 80vh;
      display: flex;
      flex-direction: column;
      margin: 0 auto;
      background: #fff;
      padding: 28px;
      border-radius: 24px;
      border: 1px solid #f0f0f0;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.04);
    }

    h1 {
      margin-top: 0;
      margin-bottom: 6px;
      font-size: 30px;
      font-weight: 800;
      letter-spacing: -0.02em;
    }

    .subtitle {
      margin: 0 0 20px;
      color: #8f8f8f;
      font-size: 14px;
    }

    .tabs {
      display: inline-flex;
      width: fit-content;
      gap: 6px;
      padding: 4px;
      border-radius: 12px;
      background: #f5f5f5;
      margin-bottom: 14px;
    }

    .tab-btn {
      border: none;
      background: transparent;
      color: #666;
      border-radius: 10px;
      font-size: 13px;
      padding: 7px 12px;
      cursor: pointer;
    }

    .tab-btn.active {
      background: #fff;
      color: #111;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    #editorPanel {
      flex: 1;
    }

    #editorPanel.active {
      display: flex;
      flex-direction: column;
    }

    .modes {
      display: flex;
      width: fit-content;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
      background: #f5f5f5;
      padding: 4px;
      border-radius: 14px;
    }

    .modes button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 999px;
      border: none;
      background: transparent;
      cursor: pointer;
      color: #585858;
    }

    .modes button.active {
      background: #fff;
      color: #111;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    }

    .editor {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      flex-grow: 1;
      align-items: stretch;
      flex: 1;
    }

    textarea,
    .output {
      width: 100%;
      min-height: 225px;
      height: 100%;
      padding: 16px;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      font-size: 16px;
      line-height: 1.6;
      border-radius: 14px;
      border: 1px solid #e0e0e0;
      background: #ffffff;
      box-sizing: border-box;
      transition: all 0.2s ease;
    }

    textarea {
      resize: vertical;
      color: #111;
    }

    textarea:focus {
      border-color: #0b57d0;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(11, 87, 208, 0.05);
      outline: none;
    }

    .output:focus {
      outline: none;
      border-color: #111;
    }

    .drop-active textarea,
    textarea.drop-active {
      border-color: #0b57d0;
      box-shadow: 0 0 0 4px rgba(11, 87, 208, 0.12);
      background: #f8fbff;
    }

    .syn-word {
      cursor: pointer;
      border-radius: 8px;
      padding: 1px 4px;
      transition: background-color 0.15s ease;
    }

    .syn-word:hover {
      background: rgba(11, 87, 208, 0.12);
    }

    .synonym-popover {
      position: fixed;
      z-index: 1000;
      min-width: 180px;
      max-width: 260px;
      background: #fff;
      border: 1px solid #eaeaea;
      border-radius: 12px;
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.12);
      padding: 8px;
      display: grid;
      gap: 6px;
    }

    .synonym-popover button {
      border: none;
      border-radius: 8px;
      background: #f7f7f7;
      color: #333;
      text-align: left;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 14px;
    }

    .synonym-popover button:hover {
      background: #eef4ff;
    }

    .synonym-loading,
    .synonym-empty {
      color: #666;
      font-size: 13px;
      padding: 6px 8px;
    }

    .output-panel {
      position: relative;
    }

    .output {
      white-space: pre-wrap;
      color: rgba(0, 0, 0, 0.78);
      background: #f5f5f5;
    }

    .output:empty::before {
      content: attr(data-placeholder);
      color: #888;
    }

    .added {
      color: #15c;
      font-weight: 500;
    }

    .diff-added {
      color: #0b57d0;
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-decoration-color: rgba(11, 87, 208, 0.65);
      font-weight: 500;
    }

    .diff-removed {
      color: #c62828;
      text-decoration: line-through;
      text-decoration-thickness: 2px;
      text-decoration-color: rgba(198, 40, 40, 0.75);
      opacity: 0.8;
    }

    .skeleton {
      display: grid;
      gap: 10px;
      padding: 4px 0;
    }

    .skeleton-line {
      height: 14px;
      border-radius: 8px;
      background: linear-gradient(90deg, #efefef 25%, #f9f9f9 50%, #efefef 75%);
      background-size: 200% 100%;
      animation: shimmer 1.4s infinite;
    }

    .skeleton-line:nth-child(1) { width: 96%; }
    .skeleton-line:nth-child(2) { width: 88%; }
    .skeleton-line:nth-child(3) { width: 92%; }
    .skeleton-line:nth-child(4) { width: 76%; }

    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .secondary-action {
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .secondary-btn {
      border: 1px solid #ddd;
      background: #fff;
      color: #333;
      border-radius: 999px;
      font-size: 13px;
      padding: 6px 12px;
      cursor: pointer;
    }

    .secondary-btn.active {
      border-color: #0b57d0;
      color: #0b57d0;
      background: #f4f8ff;
    }

    .status-label {
      font-size: 12px;
      color: #8b8b8b;
      line-height: 1.4;
    }

    .meta {
      margin-top: 8px;
      font-size: 12px;
      color: #8b8b8b;
      line-height: 1.4;
    }

    .meta:empty {
      display: none;
    }

    .copy-btn {
      position: absolute;
      right: 12px;
      bottom: 12px;
      border: none;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(255, 255, 255, 0.9);
      color: #444;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .history-list {
      margin: 6px 0 0;
      padding: 0;
      list-style: none;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    @media (max-width: 900px) {
      .history-list {
        grid-template-columns: 1fr;
      }
    }

    .history-item {
      border: 1px solid #ededed;
      border-radius: 12px;
      background: #fff;
      padding: 12px 14px;
      cursor: pointer;
    }

    .history-item:hover {
      border-color: #d9d9d9;
      background: #fcfcfc;
    }

    .history-item-title {
      margin: 0;
      font-size: 13px;
      color: #666;
    }

    .history-item-text {
      margin: 6px 0 0;
      font-size: 14px;
      color: #111;
      line-height: 1.5;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    #historyPanel {
      max-height: 70vh;
      overflow: auto;
      padding-right: 6px;
    }

    .controls {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-top: 16px;
      gap: 16px;
      flex-wrap: wrap;
    }

    select {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #ddd;
      font-size: 14px;
    }

    button#paraphrase {
      padding: 13px 24px;
      font-size: 16px;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      background: #222;
      color: #fff;
      transition: background-color 0.2s ease;
    }

    button#paraphrase:hover {
      background: #000;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    @media (max-width: 768px) {
      .editor {
        grid-template-columns: 1fr;
      }
    }

    /* ===== Style Brush (Pincel de Estilo) ===== */
    .stylebrush-menu{
      position: fixed;
      z-index: 2000;
      display: none;
      gap: 8px;
      padding: 8px;
      border-radius: 14px;
      border: 1px solid #eaeaea;
      background: rgba(255,255,255,0.98);
      box-shadow: 0 14px 30px rgba(0,0,0,0.14);
      backdrop-filter: blur(6px);
      align-items: center;
    }
    .stylebrush-menu button{
      border: none;
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 13px;
      cursor: pointer;
      background: #f5f5f5;
      color: #111;
      transition: background-color .15s ease;
    }
    .stylebrush-menu button:hover{ background:#eef4ff; }
    .stylebrush-menu button:disabled{ opacity:.6; cursor:not-allowed; }
    .stylebrush-status{
      font-size: 12px;
      color:#666;
      padding: 0 6px;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="container">
      <h1>para</h1>
      <p class="subtitle">transform your text</p>

      <div class="tabs" role="tablist" aria-label="Secciones">
        <button class="tab-btn active" type="button" data-tab="editorPanel">Editor</button>
        <button class="tab-btn" type="button" data-tab="historyPanel">Historial</button>
      </div>

      <div id="editorPanel" class="tab-panel active">
        <div class="modes">
          <button data-mode="Standard" class="active">Estándar</button>
          <button data-mode="Shorten">Acortar</button>
          <button data-mode="Expand">Expandir</button>
          <button data-mode="Simplify">Simplificar</button>
          <button data-mode="Creative">Creativo</button>
        </div>

        <div class="editor">
          <div>
            <textarea id="inputText" placeholder="Ingresa el texto que quieres parafrasear..."></textarea>
            <div id="inputCharCount" class="meta">0 caracteres</div>
          </div>

          <div class="output-panel">
            <div
              id="outputText"
              class="output"
              data-placeholder="Aquí aparecerá el texto parafraseado"
              contenteditable="true"
            ></div>
            <div class="secondary-action">
              <button id="toggleChanges" type="button" class="secondary-btn" disabled>Ver cambios</button>
              <span id="toggleStatus" class="status-label"></span>
            </div>
            <div id="outputCharCount" class="meta"></div>
            <div id="similarityText" class="meta"></div>
            <button id="copyOutput" class="copy-btn" type="button" aria-label="Copiar salida">Copy</button>
          </div>
        </div>

        <div class="controls">
            <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
            <button id="downloadPdf" type="button" class="secondary-btn" disabled>Descargar PDF</button>
            <button id="downloadDocx" type="button" class="secondary-btn" disabled>Descargar Word</button>
            <button id="paraphrase">Parafrasear</button>
          </div>
        </div>
      </div>

      <div id="historyPanel" class="tab-panel" aria-live="polite">
        <p class="subtitle" style="margin-bottom:8px;">Últimas 10 paráfrasis guardadas localmente</p>
        <ul id="historyList" class="history-list"></ul>
      </div>
    </div>
  </div>

  <div id="styleBrushMenu" class="stylebrush-menu">
    <button type="button" id="brushSimplify">Simplificar</button>
    <button type="button" id="brushProfessional">Más profesional</button>
    <span id="brushStatus" class="stylebrush-status"></span>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.11.0/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/3.0.3/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js"></script>

  <script>
    let currentMode = "Standard";
    const allowedModes = ["Standard", "Shorten", "Expand", "Simplify", "Creative"];
    const MODE_LABELS = {
      Standard: "Estándar",
      Shorten: "Acortar",
      Expand: "Expandir",
      Simplify: "Simplificar",
      Creative: "Creativo"
    };
    const TONE_LABELS = {
      Formal: "Formal",
      Casual: "Casual",
      Professional: "Profesional",
      Witty: "Ingenioso"
    };
    const DIFF_TOKEN_LIMIT = 4000;
    const HISTORY_KEY = "para.history.v1";
    const HISTORY_MAX_ITEMS = 10;
    const MAX_DROP_FILE_SIZE = 5 * 1024 * 1024;

    let diffViewEnabled = false;
    let diffButtonBlocked = true;
    let isManualEdited = false;
    let isProgrammaticUpdate = false;
    let hasReceivedFirstChunk = false;
    let currentOriginalText = "";
    let currentResultText = "";
    let currentDiff = null;
    let synonymPopover = null;
    let synonymAnchor = null;
    let synonymController = null;
    const synonymCache = new Map();

    function escapeHtml(str) {
      if (typeof str !== "string") return "";
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function tokenize(text) {
      return text.match(/\p{L}[\p{L}\p{N}_'-]*|\p{N}+|[^\s\p{L}\p{N}]|\s+/gu) || [];
    }

    function shouldJoinWithoutSpace(prev, curr) {
      if (!prev || !curr) return false;
      if (/^\s+$/.test(curr) || /^\s+$/.test(prev)) return false;

      const closers = /^[.,;:!?%)\]»”’]+$/;
      const openers = /^[(\[{«“‘¿¡]+$/;
      const apostropheLike = /^[’']$/;

      return closers.test(curr) || openers.test(prev) || apostropheLike.test(curr) || apostropheLike.test(prev);
    }

    function joinTokens(tokens) {
      let text = "";
      tokens.forEach((token, index) => {
        if (!token) return;
        if (text && !shouldJoinWithoutSpace(tokens[index - 1], token)) {
          text += " ";
        }
        text += token;
      });
      return text;
    }

    function renderTokens(tokens, mode) {
      let html = "";
      tokens.forEach((token, i) => {
        if (!token?.value) return;

        const escaped = escapeHtml(token.value);
        let wrapped = escaped;

        if (mode === "simple") {
          if (token.type === "removed") return;
          if (token.type === "added") {
            const outIndexAttr = Number.isInteger(token.outIndex) ? ` data-out-index="${token.outIndex}"` : "";
            wrapped = `<span class="added syn-word"${outIndexAttr} data-token="${escaped}">${escaped}</span>`;
          }
        } else if (mode === "diff") {
          if (token.type === "added") {
            const outIndexAttr = Number.isInteger(token.outIndex) ? ` data-out-index="${token.outIndex}"` : "";
            wrapped = `<span class="diff-added syn-word"${outIndexAttr} data-token="${escaped}">${escaped}</span>`;
          } else if (token.type === "removed") {
            wrapped = `<span class="diff-removed">${escaped}</span>`;
          }
        }

        if (html.length > 0 && !shouldJoinWithoutSpace(tokens[i - 1]?.value, token.value)) {
          html += " ";
        }

        html += wrapped;
      });

      return html;
    }

    function buildDiffData(originalText, paraphrasedText) {
      const origTokens = tokenize(originalText).filter(t => !/^\s+$/.test(t));
      const outTokens = tokenize(paraphrasedText).filter(t => !/^\s+$/.test(t));

      if (!outTokens.length) {
        return { tokens: [], outTokens: [], addedCount: 0, totalCount: 0, diffDisabled: false };
      }

      if (origTokens.length + outTokens.length > DIFF_TOKEN_LIMIT) {
        return {
          tokens: outTokens.map((token, idx) => ({ value: token, type: "equal", outIndex: idx })),
          outTokens,
          addedCount: 0,
          totalCount: outTokens.length,
          diffDisabled: true
        };
      }

      const n = origTokens.length;
      const m = outTokens.length;
      const dp = Array.from({ length: n + 1 }, () => new Uint16Array(m + 1));

      for (let i = n - 1; i >= 0; i--) {
        for (let j = m - 1; j >= 0; j--) {
          if (origTokens[i] === outTokens[j]) {
            dp[i][j] = dp[i + 1][j + 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
          }
        }
      }

      const tokens = [];
      let i = 0;
      let j = 0;

      while (i < n && j < m) {
        if (origTokens[i] === outTokens[j]) {
          tokens.push({ value: outTokens[j], type: "equal", outIndex: j });
          i++;
          j++;
        } else if (dp[i][j + 1] >= dp[i + 1][j]) {
          tokens.push({ value: outTokens[j], type: "added", outIndex: j });
          j++;
        } else {
          tokens.push({ value: origTokens[i], type: "removed" });
          i++;
        }
      }

      while (i < n) {
        tokens.push({ value: origTokens[i], type: "removed" });
        i++;
      }

      while (j < m) {
        tokens.push({ value: outTokens[j], type: "added", outIndex: j });
        j++;
      }

      const addedCount = tokens.filter(token => token.type === "added").length;
      const totalCount = tokens.filter(token => token.type !== "removed").length;

      return { tokens, outTokens, addedCount, totalCount, diffDisabled: false };
    }

    const modeButtons = document.querySelectorAll(".modes button");
    const tabButtons = document.querySelectorAll(".tab-btn");
    const input = document.getElementById("inputText");
    const inputText = input;
    const styleBrushMenu = document.getElementById("styleBrushMenu");
    const brushSimplifyBtn = document.getElementById("brushSimplify");
    const brushProfessionalBtn = document.getElementById("brushProfessional");
    const brushStatus = document.getElementById("brushStatus");

    let lastMouseX = 0;
    let lastMouseY = 0;

    function setBrushLoading(isLoading, msg = "") {
      brushSimplifyBtn.disabled = isLoading;
      brushProfessionalBtn.disabled = isLoading;
      brushStatus.textContent = msg;
    }

    function hideStyleBrush() {
      styleBrushMenu.style.display = "none";
      setBrushLoading(false, "");
    }

    function showStyleBrush(x, y) {
      styleBrushMenu.style.left = `${x}px`;
      styleBrushMenu.style.top = `${y - 50}px`;
      styleBrushMenu.style.display = "inline-flex";
    }

    function getSelectionData() {
      const start = inputText.selectionStart;
      const end = inputText.selectionEnd;
      if (end <= start) return null;

      const full = inputText.value;
      const selected = full.slice(start, end);
      if (!selected.trim()) return null;

      return { start, end, selected, full };
    }

    async function applyStyle(effect) {
      if (isManualEdited) return;

      const sel = getSelectionData();
      if (!sel) return;

      setBrushLoading(true, "Aplicando…");

      try {
        const res = await fetch("/api/stylebrush", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            effect,
            selectedText: sel.selected,
            before: sel.full.slice(Math.max(0, sel.start - 500), sel.start),
            after: sel.full.slice(sel.end, sel.end + 500)
          })
        });

        const data = await res.json();
        if (!data.replacement) throw new Error();

        const baseText = currentResultText || inputText.value;

        const newText =
          baseText.slice(0, sel.start) +
          data.replacement +
          baseText.slice(sel.end);

        currentOriginalText = inputText.value;
        currentResultText = newText;
        currentDiff = buildDiffData(currentOriginalText, currentResultText);

        diffViewEnabled = false;
        isManualEdited = false;

        applyOutputView();
        outputCharCount.textContent = `${currentResultText.length} caracteres`;

        const similarity = currentDiff.totalCount
          ? Math.round(100 - (currentDiff.addedCount / currentDiff.totalCount) * 100)
          : 100;

        similarityText.textContent = getSimilarityLabel(similarity);

        hideStyleBrush();

      } catch {
        setBrushLoading(false, "Error");
        setTimeout(() => setBrushLoading(false, ""), 1000);
      }
    }

    inputText.addEventListener("mousedown", e => {
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    inputText.addEventListener("mouseup", e => {
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;

      const sel = getSelectionData();
      if (!sel) return hideStyleBrush();
      showStyleBrush(lastMouseX, lastMouseY);
    });

    brushSimplifyBtn.onclick = () => applyStyle("simplify");
    brushProfessionalBtn.onclick = () => applyStyle("professional");

    document.addEventListener("click", e => {
      if (!styleBrushMenu.contains(e.target) && e.target !== inputText) {
        hideStyleBrush();
      }
    });

    document.addEventListener("keydown", e => {
      if (e.key === "Escape") hideStyleBrush();
    });
    const output = document.getElementById("outputText");
    const editor = document.querySelector(".editor");
    const btn = document.getElementById("paraphrase");
    const copyBtn = document.getElementById("copyOutput");
    const downloadPdfBtn = document.getElementById("downloadPdf");
    const downloadDocxBtn = document.getElementById("downloadDocx");
    const inputCharCount = document.getElementById("inputCharCount");
    const outputCharCount = document.getElementById("outputCharCount");
    const similarityText = document.getElementById("similarityText");
    const toggleChanges = document.getElementById("toggleChanges");
    const toggleStatus = document.getElementById("toggleStatus");
    const historyList = document.getElementById("historyList");

    function switchToEditorTab() {
      tabButtons.forEach(button => button.classList.toggle("active", button.dataset.tab === "editorPanel"));
      document.getElementById("editorPanel").classList.add("active");
      document.getElementById("historyPanel").classList.remove("active");
    }

    function setParaphraseLabel(isLoading) {
      btn.textContent = isLoading ? "Parafraseando…" : "Parafrasear";
    }

    function getSimilarityLabel(similarity) {
      if (similarity >= 80) return "Cambios leves";
      if (similarity >= 60) return "Cambios moderados";
      return "Reescritura profunda";
    }

    function setOutputHtml(html) {
      isProgrammaticUpdate = true;
      output.innerHTML = html;
      isProgrammaticUpdate = false;
    }

    function updateExportButtons() {
      const hasOutput = Boolean(currentResultText.trim());
      downloadPdfBtn.disabled = !hasOutput;
      downloadDocxBtn.disabled = !hasOutput;
    }

    function disableDiffButton(message = "") {
      diffButtonBlocked = true;
      diffViewEnabled = false;
      toggleChanges.classList.remove("active");
      toggleChanges.setAttribute("aria-pressed", "false");
      toggleChanges.disabled = true;
      toggleStatus.textContent = message;
    }

    function enableDiffButton(message = "") {
      diffButtonBlocked = false;
      toggleChanges.disabled = false;
      toggleStatus.textContent = message;
    }

    function applyOutputView() {
      if (!currentDiff) {
        setOutputHtml(escapeHtml(currentResultText));
      } else {
        const mode = diffViewEnabled ? "diff" : "simple";
        setOutputHtml(renderTokens(currentDiff.tokens, mode));
      }
      toggleChanges.classList.toggle("active", diffViewEnabled);
      toggleChanges.setAttribute("aria-pressed", diffViewEnabled ? "true" : "false");
      updateExportButtons();
    }

    function updateInputCount() {
      inputCharCount.textContent = `${input.value.length} caracteres`;
    }

    function setActiveMode(mode) {
      const nextMode = allowedModes.includes(mode) ? mode : "Standard";
      currentMode = nextMode;
      modeButtons.forEach(button => button.classList.toggle("active", button.dataset.mode === nextMode));
    }

    function saveHistoryEntry(entry) {
      const items = loadHistory();
      items.unshift(entry);
      localStorage.setItem(HISTORY_KEY, JSON.stringify(items.slice(0, HISTORY_MAX_ITEMS)));
      renderHistory();
    }

    function loadHistory() {
      try {
        const parsed = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]");
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function formatTimestamp(value) {
      return new Date(value).toLocaleString("es-ES", { dateStyle: "short", timeStyle: "short" });
    }

    function renderHistory() {
      const items = loadHistory();
      historyList.innerHTML = "";

      if (!items.length) {
        historyList.innerHTML = '<li class="history-item" style="cursor:default;"><p class="history-item-title">Aún no hay historial</p><p class="history-item-text">Las paráfrasis recientes aparecerán aquí.</p></li>';
        return;
      }

      items.forEach((item) => {
        const safeResult = typeof item.result === "string" ? item.result : "";
        const safeMode = item.mode || "Standard";
        const safeTone = item.tone || "Formal";
        const safeOriginal = typeof item.original === "string" ? item.original : "";
        const modeLabel = MODE_LABELS[safeMode] || safeMode;
        const toneLabel = TONE_LABELS[safeTone] || safeTone;

        const li = document.createElement("li");
        li.className = "history-item";
        li.innerHTML = `
          <p class="history-item-title">${escapeHtml(formatTimestamp(item.timestamp))} · ${escapeHtml(modeLabel)} · ${escapeHtml(toneLabel)}</p>
          <p class="history-item-text">${escapeHtml(safeResult.slice(0, 160))}${safeResult.length > 160 ? "…" : ""}</p>
        `;

        li.addEventListener("click", () => {
          input.value = safeOriginal;
          updateInputCount();
          setActiveMode(safeMode);

          currentOriginalText = safeOriginal;
          currentResultText = safeResult;
          currentDiff = buildDiffData(currentOriginalText, currentResultText);

          isManualEdited = false;
          diffViewEnabled = false;
          applyOutputView();

          if (currentDiff.diffDisabled) {
            disableDiffButton("Cambios no disponibles por longitud del texto");
          } else {
            enableDiffButton("");
          }

          outputCharCount.textContent = `${safeResult.length} caracteres`;
          const similarity = currentDiff.totalCount
            ? Math.round(100 - (currentDiff.addedCount / currentDiff.totalCount) * 100)
            : 100;
          similarityText.textContent = getSimilarityLabel(similarity);
          switchToEditorTab();
        });

        historyList.appendChild(li);
      });
    }

    function showSkeleton() {
      const html = `
        <div class="skeleton" aria-hidden="true">
          <div class="skeleton-line"></div>
          <div class="skeleton-line"></div>
          <div class="skeleton-line"></div>
          <div class="skeleton-line"></div>
        </div>
      `;
      setOutputHtml(html);
    }

    function isEligibleSynonymToken(word) {
      if (!word || word.length < 2 || word.length > 40) return false;
      if (!/[\p{L}]/u.test(word)) return false;
      if (/^\d+(?:[.,]\d+)?$/.test(word)) return false;
      if (/^[A-ZÁÉÍÓÚÑ][a-záéíóúñ]+(?:[A-ZÁÉÍÓÚÑ][a-záéíóúñ]+)*$/.test(word)) return false;
      if (/^(https?:\/\/|www\.)/i.test(word)) return false;
      if (/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(word)) return false;
      return true;
    }

    function closeSynonymPopover() {
      if (synonymController) {
        synonymController.abort();
        synonymController = null;
      }
      if (synonymPopover) {
        synonymPopover.remove();
        synonymPopover = null;
      }
      synonymAnchor = null;
    }

    function openSynonymPopover(anchor) {
      closeSynonymPopover();
      synonymAnchor = anchor;
      const rect = anchor.getBoundingClientRect();
      const popover = document.createElement("div");
      popover.className = "synonym-popover";
      popover.style.left = `${Math.min(window.innerWidth - 280, Math.max(8, rect.left))}px`;
      popover.style.top = `${Math.min(window.innerHeight - 120, rect.bottom + 8)}px`;
      popover.innerHTML = '<div class="synonym-loading">Cargando…</div>';
      document.body.appendChild(popover);
      synonymPopover = popover;
      return popover;
    }

    function applyCapitalization(sourceWord, replacementWord) {
      if (!sourceWord || !replacementWord) return replacementWord;
      if (/^[A-ZÁÉÍÓÚÑ]/.test(sourceWord)) {
        return replacementWord.charAt(0).toUpperCase() + replacementWord.slice(1);
      }
      return replacementWord;
    }

    async function fetchSynonyms(word, context) {
      const key = `${word.toLowerCase()}|${context}`;
      if (synonymCache.has(key)) return synonymCache.get(key);

      synonymController = new AbortController();
      try {
        const response = await fetch("/api/synonyms", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ word, context, mode: currentMode }),
          signal: synonymController.signal
        });
        const data = await response.json().catch(() => ({ synonyms: [] }));
        const synonyms = Array.isArray(data.synonyms) ? data.synonyms.slice(0, 4) : [];
        synonymCache.set(key, synonyms);
        return synonyms;
      } catch {
        return [];
      } finally {
        synonymController = null;
      }
    }

    async function onSynWordClick(event) {
      const target = event.target.closest(".syn-word");
      if (!target || !output.contains(target) || !currentDiff?.outTokens?.length) return;
      const outIndex = Number.parseInt(target.dataset.outIndex, 10);
      if (!Number.isInteger(outIndex) || outIndex < 0 || outIndex >= currentDiff.outTokens.length) return;

      const currentWord = currentDiff.outTokens[outIndex];
      if (!isEligibleSynonymToken(currentWord)) {
        const pop = openSynonymPopover(target);
        pop.innerHTML = '<div class="synonym-empty">Sin alternativas útiles</div>';
        return;
      }

      if (synonymAnchor === target && synonymPopover) {
        closeSynonymPopover();
        return;
      }

      const popover = openSynonymPopover(target);
      const context = joinTokens(currentDiff.outTokens.slice(Math.max(0, outIndex - 15), outIndex + 16)).slice(0, 900);
      const synonyms = await fetchSynonyms(currentWord, context);
      if (!synonymPopover || synonymAnchor !== target) return;

      if (!synonyms.length) {
        popover.innerHTML = '<div class="synonym-empty">Sin alternativas útiles</div>';
        return;
      }

      popover.innerHTML = "";
      synonyms.forEach((synonym) => {
        const optionButton = document.createElement("button");
        optionButton.type = "button";
        optionButton.textContent = synonym;
        optionButton.addEventListener("click", () => {
          const outTokens = [...currentDiff.outTokens];
          outTokens[outIndex] = applyCapitalization(currentWord, synonym);
          currentResultText = joinTokens(outTokens);
          currentDiff = buildDiffData(currentOriginalText, currentResultText);
          diffViewEnabled = false;
          applyOutputView();
          outputCharCount.textContent = `${currentResultText.length} caracteres`;
          const similarity = currentDiff.totalCount
            ? Math.round(100 - (currentDiff.addedCount / currentDiff.totalCount) * 100)
            : 100;
          similarityText.textContent = getSimilarityLabel(similarity);
          closeSynonymPopover();
        });
        popover.appendChild(optionButton);
      });
    }

    function clearOutputState() {
      currentOriginalText = "";
      currentResultText = "";
      currentDiff = null;
      diffViewEnabled = false;
      isManualEdited = false;
      setOutputHtml("");
      outputCharCount.textContent = "";
      similarityText.textContent = "";
      disableDiffButton("");
      updateExportButtons();
      closeSynonymPopover();
    }

    async function extractFileText(file) {
      if (!file) return "";
      const name = file.name.toLowerCase();
      if (file.size > MAX_DROP_FILE_SIZE) {
        throw new Error("El archivo supera el límite de 5MB.");
      }
      if (name.endsWith(".txt")) {
        return await file.text();
      }
      if (name.endsWith(".docx")) {
        if (!window.mammoth) throw new Error("No se pudo cargar Mammoth para leer DOCX.");
        const arrayBuffer = await file.arrayBuffer();
        const result = await window.mammoth.extractRawText({ arrayBuffer });
        return result.value || "";
      }
      throw new Error("Solo se admiten archivos .txt o .docx.");
    }

    async function handleDroppedFile(file) {
      try {
        const text = await extractFileText(file);
        if (!text.trim()) {
          setOutputHtml("El archivo no contiene texto legible.");
          return;
        }
        input.value = text;
        updateInputCount();
        switchToEditorTab();
        clearOutputState();
      } catch (error) {
        setOutputHtml(escapeHtml(error.message || "No se pudo leer el archivo."));
      }
    }

    function installDragAndDrop() {
      let dragDepth = 0;
      const activateDrop = () => {
        editor.classList.add("drop-active");
        input.classList.add("drop-active");
      };
      const clearDrop = () => {
        editor.classList.remove("drop-active");
        input.classList.remove("drop-active");
      };

      const onDragOver = (event) => {
        event.preventDefault();
        event.dataTransfer.dropEffect = "copy";
      };

      [editor, input].forEach((el) => {
        el.addEventListener("dragenter", (event) => {
          event.preventDefault();
          dragDepth += 1;
          activateDrop();
        });
        el.addEventListener("dragover", onDragOver);
        el.addEventListener("dragleave", (event) => {
          event.preventDefault();
          dragDepth = Math.max(0, dragDepth - 1);
          if (!dragDepth) clearDrop();
        });
        el.addEventListener("drop", async (event) => {
          event.preventDefault();
          dragDepth = 0;
          clearDrop();
          const file = event.dataTransfer?.files?.[0];
          if (file) await handleDroppedFile(file);
        });
      });
    }

    function downloadPdf() {
      if (!currentResultText.trim() || !window.jspdf?.jsPDF) return;
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit: "pt", format: "a4" });
      const margin = 48;
      const pageWidth = doc.internal.pageSize.getWidth() - margin * 2;
      const pageHeight = doc.internal.pageSize.getHeight() - margin * 2;
      const lines = doc.splitTextToSize(currentResultText, pageWidth);
      let y = margin;
      doc.setFontSize(12);
      lines.forEach((line) => {
        if (y > margin + pageHeight) {
          doc.addPage();
          y = margin;
        }
        doc.text(line, margin, y);
        y += 18;
      });
      doc.save("para.pdf");
    }

    async function downloadDocx() {
      if (!currentResultText.trim() || !window.docx) return;
      const { Document, Packer, Paragraph, TextRun } = window.docx;
      const paragraphs = currentResultText.split(/\n+/).map(line => new Paragraph({ children: [new TextRun(line)] }));
      const doc = new Document({ sections: [{ children: paragraphs.length ? paragraphs : [new Paragraph("")] }] });
      const blob = await Packer.toBlob(doc);
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "para.docx";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    updateInputCount();
    renderHistory();
    updateExportButtons();
    installDragAndDrop();

    input.addEventListener("input", updateInputCount);

    tabButtons.forEach(tabBtn => {
      tabBtn.addEventListener("click", () => {
        tabButtons.forEach(button => button.classList.toggle("active", button === tabBtn));
        document.querySelectorAll(".tab-panel").forEach(panel => panel.classList.remove("active"));
        document.getElementById(tabBtn.dataset.tab).classList.add("active");
      });
    });

    modeButtons.forEach(btnMode => {
      btnMode.addEventListener("click", () => {
        setActiveMode(btnMode.dataset.mode);
      });
    });

    toggleChanges.addEventListener("click", () => {
      if (diffButtonBlocked || !currentDiff || isManualEdited) return;
      diffViewEnabled = !diffViewEnabled;
      applyOutputView();
    });

    output.addEventListener("click", onSynWordClick);

    document.addEventListener("click", (event) => {
      if (!synonymPopover) return;
      if (synonymPopover.contains(event.target)) return;
      if (event.target.closest(".syn-word") === synonymAnchor) return;
      closeSynonymPopover();
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") closeSynonymPopover();
    });

    output.addEventListener("input", () => {
      if (isProgrammaticUpdate || !currentResultText) return;

      isManualEdited = true;
      diffViewEnabled = false;
      disableDiffButton("Editado manualmente");
      outputCharCount.textContent = `${output.textContent.length} caracteres`;
      similarityText.textContent = "";
      updateExportButtons();
    });

    btn.addEventListener("click", async () => {
      const text = input.value.trim();
      if (!text) return;

      const STREAM_TIMEOUT_MS = 25000;
      const controller = new AbortController();
      let reader;
      let timeoutId;
      let streamTimedOut = false;

      btn.disabled = true;
      setParaphraseLabel(true);
      outputCharCount.textContent = "";
      similarityText.textContent = "";

      disableDiffButton("");
      isManualEdited = false;
      hasReceivedFirstChunk = false;
      currentOriginalText = text;
      currentResultText = "";
      currentDiff = null;
      updateExportButtons();
      showSkeleton();

      try {
        timeoutId = setTimeout(() => {
          streamTimedOut = true;
          controller.abort();
          if (reader) {
            reader.cancel("timeout").catch(() => {});
          }
        }, STREAM_TIMEOUT_MS);

        const res = await fetch("/api/summary", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            text,
            mode: currentMode
          }),
          signal: controller.signal
        });

        if (!res.ok || !res.body) {
          if (res.status === 413) {
            throw new Error("El texto es demasiado largo, intenta con un párrafo más corto.");
          }
          throw new Error("No se pudo generar el texto. Intenta nuevamente.");
        }

        reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let streamDone = false;

        while (!streamDone) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const events = buffer.split("\n\n");
          buffer = events.pop() || "";

          for (const eventBlock of events) {
            const line = eventBlock
              .split("\n")
              .find(lineItem => lineItem.startsWith("data:"));

            if (!line) continue;

            const payloadText = line.replace(/^data:\s*/, "");
            if (!payloadText || payloadText === "[DONE]") continue;

            const payload = JSON.parse(payloadText);

            if (payload.type === "chunk" && payload.text) {
              currentResultText += payload.text;

              if (!hasReceivedFirstChunk) {
                hasReceivedFirstChunk = true;
              }

              setOutputHtml(escapeHtml(currentResultText));
              outputCharCount.textContent = `${currentResultText.length} caracteres`;
              updateExportButtons();
            }

            if (payload.type === "error") {
              throw new Error(payload.message || "No se pudo generar el texto. Intenta nuevamente.");
            }

            if (payload.type === "done") {
              streamDone = true;
              break;
            }
          }
        }

        if (streamTimedOut) {
          throw new Error("La generación tardó demasiado. Intenta nuevamente.");
        }

        if (!currentResultText.trim()) {
          throw new Error("No se pudo generar el texto. Intenta nuevamente.");
        }

        currentDiff = buildDiffData(currentOriginalText, currentResultText);
        diffViewEnabled = false;
        applyOutputView();

        if (currentDiff.diffDisabled) {
          disableDiffButton("Cambios no disponibles por longitud del texto");
        } else {
          enableDiffButton("");
        }

        const similarity = currentDiff.totalCount
          ? Math.round(100 - (currentDiff.addedCount / currentDiff.totalCount) * 100)
          : 100;
        similarityText.textContent = getSimilarityLabel(similarity);

        saveHistoryEntry({
          original: currentOriginalText,
          result: currentResultText,
          mode: currentMode,
          timestamp: Date.now()
        });
      } catch (err) {
        const isTooLongError = err?.message === "El texto es demasiado largo, intenta con un párrafo más corto.";
        const isTimeoutError = streamTimedOut || err?.name === "AbortError";
        const message = isTooLongError
          ? err.message
          : isTimeoutError
            ? "La generación tardó demasiado. Reintenta en unos segundos."
            : "No se pudo generar el texto. Intenta nuevamente.";

        setOutputHtml(escapeHtml(message));
        outputCharCount.textContent = "";
        similarityText.textContent = "";
      } finally {
        clearTimeout(timeoutId);
        if (reader) {
          reader.cancel().catch(() => {});
        }
        btn.disabled = false;
        setParaphraseLabel(false);
        updateExportButtons();
      }
    });

    copyBtn.addEventListener("click", async () => {
      const text = output.textContent.trim();
      if (!text) return;

      try {
        await navigator.clipboard.writeText(text);
        copyBtn.textContent = "Copied";
        setTimeout(() => {
          copyBtn.textContent = "Copy";
        }, 1200);
      } catch {
        copyBtn.textContent = "Error";
        setTimeout(() => {
          copyBtn.textContent = "Copy";
        }, 1200);
      }
    });

    downloadPdfBtn.addEventListener("click", downloadPdf);
    downloadDocxBtn.addEventListener("click", () => {
      downloadDocx().catch(() => {});
    });
  </script>


</body>
</html>
