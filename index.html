<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>para ‚Äî parafrasear texto</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root{
      --editor-box-h: clamp(300px, 46vh, 520px);
    }

    html,
    body {
      height: 100%;
    }

    [hidden] {
      display: none !important;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: linear-gradient(180deg, #ffffff 0%, #f9f9f9 100%);
      margin: 0;
      min-height: 100vh;
      color: #111;
    }

    .page {
      min-height: 100vh;
      padding: 40px;
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      min-height: 80vh;
      display: flex;
      flex-direction: column;
      margin: 0 auto;
      background: #fff;
      padding: 28px;
      border-radius: 24px;
      border: 1px solid #f0f0f0;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.04);
    }

    .header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 20px;
    }

    .header-left {
      flex: 1;
    }

    h1 {
      margin-top: 0;
      margin-bottom: 6px;
      font-size: 30px;
      font-weight: 800;
      letter-spacing: -0.02em;
    }

    .subtitle {
      margin: 0;
      color: #8f8f8f;
      font-size: 14px;
    }

    .history-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      border: 1px solid #e0e0e0;
      background: #fff;
      color: #333;
      border-radius: 10px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .history-btn:hover {
      background: #f9f9f9;
      border-color: #ccc;
    }

    .history-btn svg {
      width: 18px;
      height: 18px;
      stroke-width: 2;
    }

    #editorPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .modes {
      display: flex;
      width: fit-content;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
      background: #f5f5f5;
      padding: 4px;
      border-radius: 14px;
    }

    .modes button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 999px;
      border: none;
      background: transparent;
      cursor: pointer;
      color: #585858;
    }

    .modes button.active {
      background: #fff;
      color: #111;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    }

    .mode-help {
      margin: 0 0 16px;
      font-size: 12px;
      color: #8b8b8b;
      line-height: 1.4;
    }

    .editor {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      flex-grow: 1;
      align-items: stretch;
      flex: 1;
    }

    .correction-mode .editor {
      grid-template-columns: 1fr 360px;
    }

    .correction-mode .output-panel {
      display: none;
    }

    .editor > div,
    .output-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    textarea,
    .output {
      width: 100%;
      min-height: 0;
      height: 100%;
      padding: 16px;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      font-size: 16px;
      line-height: 1.6;
      border-radius: 14px;
      border: 1px solid #e0e0e0;
      background: #ffffff;
      box-sizing: border-box;
      transition: all 0.2s ease;
    }

    textarea {
      resize: none;
      color: #111;
    }

    #inputText,
    #outputText {
      flex: 1;
    }

    textarea:focus {
      border-color: #0b57d0;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(11, 87, 208, 0.05);
      outline: none;
    }

    .output:focus {
      outline: none;
      border-color: #111;
    }

    .drop-active textarea,
    textarea.drop-active {
      border-color: #0b57d0;
      box-shadow: 0 0 0 4px rgba(11, 87, 208, 0.12);
      background: #f8fbff;
    }

    .syn-word {
      cursor: pointer;
      border-radius: 8px;
      padding: 1px 4px;
      transition: background-color 0.15s ease;
    }

    .syn-word:hover {
      background: rgba(11, 87, 208, 0.12);
    }

    .synonym-popover {
      position: fixed;
      z-index: 1000;
      min-width: 180px;
      max-width: 260px;
      background: #fff;
      border: 1px solid #eaeaea;
      border-radius: 12px;
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.12);
      padding: 8px;
      display: grid;
      gap: 6px;
    }

    .synonym-popover button {
      border: none;
      border-radius: 8px;
      background: #f7f7f7;
      color: #333;
      text-align: left;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 14px;
    }

    .synonym-popover button:hover {
      background: #eef4ff;
    }

    .synonym-loading,
    .synonym-empty {
      color: #666;
      font-size: 13px;
      padding: 6px 8px;
    }

    .output-panel {
      position: relative;
      min-height: 0;
    }

    .input-panel {
      position: relative;
      display: flex;
      flex-direction: column;
      flex: 0 0 auto;
      height: var(--editor-box-h);
      min-height: 0;
    }

    .output {
      white-space: pre-wrap;
      color: rgba(0, 0, 0, 0.78);
      background: #f5f5f5;
    }

    .output:empty::before {
      content: attr(data-placeholder);
      color: #888;
    }

    .added {
      color: #15c;
      font-weight: 500;
    }

    .diff-added {
      color: #0b57d0;
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-decoration-color: rgba(11, 87, 208, 0.65);
      font-weight: 500;
    }

    .diff-removed {
      color: #c62828;
      text-decoration: line-through;
      text-decoration-thickness: 2px;
      text-decoration-color: rgba(198, 40, 40, 0.75);
      opacity: 0.8;
    }

    .skeleton {
      display: grid;
      gap: 10px;
      padding: 4px 0;
    }

    .skeleton-line {
      height: 14px;
      border-radius: 8px;
      background: linear-gradient(90deg, #efefef 25%, #f9f9f9 50%, #efefef 75%);
      background-size: 200% 100%;
      animation: shimmer 1.4s infinite;
    }

    .skeleton-line:nth-child(1) { width: 96%; }
    .skeleton-line:nth-child(2) { width: 88%; }
    .skeleton-line:nth-child(3) { width: 92%; }
    .skeleton-line:nth-child(4) { width: 76%; }

    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .secondary-btn {
      border: 1px solid #ddd;
      background: #fff;
      color: #333;
      border-radius: 999px;
      font-size: 13px;
      padding: 6px 12px;
      cursor: pointer;
    }

    .secondary-btn.active {
      border-color: #0b57d0;
      color: #0b57d0;
      background: #f4f8ff;
    }

    .translate-wrap {
      position: relative;
      display: inline-flex;
    }

    .translate-menu {
      position: absolute;
      top: calc(100% + 6px);
      right: 0;
      min-width: 140px;
      background: #fff;
      border: 1px solid #eaeaea;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
      padding: 6px;
      display: grid;
      gap: 4px;
      z-index: 100;
    }

    .translate-menu button {
      border: none;
      border-radius: 8px;
      background: transparent;
      color: #333;
      text-align: left;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background 0.15s ease;
    }

    .translate-menu button:hover {
      background: #f5f5f5;
    }

    .translate-menu button.active {
      background: #eef4ff;
      color: #0b57d0;
    }

    .translate-banner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #eef4ff;
      border: 1px solid #d4e4ff;
      border-radius: 10px;
      padding: 8px 12px;
      margin-bottom: 12px;
      font-size: 13px;
      color: #0b57d0;
    }

    .translate-banner-left {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .translate-banner button {
      border: none;
      background: transparent;
      color: #0b57d0;
      cursor: pointer;
      font-size: 13px;
      text-decoration: underline;
      padding: 0;
    }

    .translate-banner button:hover {
      color: #084298;
    }

    .status-label {
      font-size: 12px;
      color: #8b8b8b;
      line-height: 1.4;
    }

    .meta {
      margin-top: 8px;
      font-size: 12px;
      color: #8b8b8b;
      line-height: 1.4;
    }

    .meta:empty {
      display: none;
    }

    .copy-btn {
      position: absolute;
      right: 12px;
      bottom: 12px;
      border: none;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(255, 255, 255, 0.9);
      color: #444;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .history-list {
      margin: 6px 0 0;
      padding: 0;
      list-style: none;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    @media (max-width: 900px) {
      .history-list {
        grid-template-columns: 1fr;
      }
    }

    .history-item {
      border: 1px solid #ededed;
      border-radius: 12px;
      background: #fff;
      padding: 12px 14px;
      cursor: pointer;
    }

    .history-item:hover {
      border-color: #d9d9d9;
      background: #fcfcfc;
    }

    .history-item-title {
      margin: 0;
      font-size: 13px;
      color: #666;
    }

    .history-item-text {
      margin: 6px 0 0;
      font-size: 14px;
      color: #111;
      line-height: 1.5;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    #historyPanel {
      max-height: 70vh;
      overflow: auto;
      padding-right: 6px;
    }

    .history-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .history-modal-content {
      background: #fff;
      border-radius: 16px;
      width: 100%;
      max-width: 900px;
      max-height: 80vh;
      overflow: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
    }

    .history-modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 1;
    }

    .history-modal-title {
      font-size: 20px;
      font-weight: 600;
      margin: 0;
    }

    .history-modal-body {
      padding: 24px;
    }

    .history-close {
      border: none;
      background: transparent;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
    }

    .history-close:hover {
      background: #f5f5f5;
    }

    .controls {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-top: 16px;
      gap: 16px;
      flex-wrap: wrap;
    }

    .paraphrase-controls {
      margin-top: 12px;
      justify-content: center;
    }

    select {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #ddd;
      font-size: 14px;
    }

    button#paraphrase {
      padding: 13px 24px;
      font-size: 16px;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      background: #222;
      color: #fff;
      transition: background-color 0.2s ease;
    }

    button#paraphrase:hover {
      background: #000;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    @media (max-width: 768px) {
      .editor {
        grid-template-columns: 1fr;
      }
      
      /* En m√≥viles, el panel de correcciones aparece debajo */
      .correction-mode .editor {
        grid-template-columns: 1fr;
        gap: 16px;
      }
      
      .correction-mode .correction-panel {
        /* En m√≥vil, altura m√°xima m√°s peque√±a */
        max-height: 400px;
      }
    }

    .kebab-wrap{
      position: relative;
      display: inline-flex;
    }

    .kebab-btn{
      width:34px;
      height:34px;
      border-radius:10px;
      border:1px solid #e6e6e6;
      background: rgba(255,255,255,0.95);
      color:#222;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      line-height:1;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }
    .kebab-btn:hover{ background:#fff; border-color:#d9d9d9; }

    .kebab-menu{
      position:absolute;
      top:40px;
      right:0;
      min-width: 190px;
      background:#fff;
      border:1px solid #eaeaea;
      border-radius: 12px;
      box-shadow: 0 14px 30px rgba(0,0,0,0.12);
      padding: 6px;
      display:grid;
      gap:6px;
      z-index: 40;
    }
    .kebab-item{
      border:none;
      border-radius:10px;
      background:#f7f7f7;
      color:#111;
      text-align:left;
      padding:10px 10px;
      cursor:pointer;
      font-size:14px;
    }
    .kebab-item:hover{ background:#eef4ff; }
    .kebab-item:disabled{ opacity:0.5; cursor:not-allowed; }

    .copy-btn{ z-index: 25; }

    /* Wrapper del cuadro de salida para anclar el bot√≥n Copiar */
    .output-box{
      position: relative;
      flex: 0 0 auto;
      height: var(--editor-box-h);
      min-height: 0;
      display: flex;
    }

    /* Asegura que el √°rea editable ocupe toda la altura del wrapper */
    .output-box .output{
      height: 100%;
      min-height: 0;
    }

    .input-panel textarea{
      height: 100%;
      min-height: 0;
    }

    /* Transici√≥n suave al ocultar columna izquierda */
    .editor{
      transition: grid-template-columns .25s ease, gap .25s ease;
    }

    /* Cuando se oculta la entrada, la salida ocupa todo */
    .editor.hide-input{
      grid-template-columns: 0 1fr;
      gap: 0;
    }

    /* Oculta el panel izquierdo de forma suave y deshabilita interacci√≥n */
    .editor.hide-input > div:first-child{
      opacity: 0;
      transform: translateX(-10px);
      pointer-events: none;
      overflow: hidden;
      transition: opacity .2s ease, transform .25s ease;
    }

    /* Estado normal del panel izquierdo (para transici√≥n de vuelta) */
    .editor > div:first-child{
      transition: opacity .2s ease, transform .25s ease;
    }

    .modal-backdrop{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.35);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 1000;
    }
    .modal-card{
      width: min(720px, 100%);
      background:#fff;
      border-radius: 18px;
      border: 1px solid #ededed;
      box-shadow: 0 20px 60px rgba(0,0,0,0.18);
      padding: 16px;
    }
    .modal-header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    .modal-title{ font-weight: 800; font-size: 16px; }
    .modal-sub{ color:#8b8b8b; font-size: 12px; margin-top: 2px; }
    .modal-close{
      border:1px solid #e6e6e6;
      background:#fff;
      border-radius: 10px;
      width: 34px;
      height: 34px;
      cursor:pointer;
    }
    .modal-controls{
      display:flex;
      justify-content:flex-start;
      margin: 10px 0 8px 0;
    }
    .modal-select{
      width: 240px;
      max-width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #e6e6e6;
      background: #fff;
      font-size: 13px;
    }
    .modal-loading{ color:#666; font-size: 13px; padding: 6px 2px; }
    .modal-text{
      width:100%;
      min-height: 240px;
      resize: vertical;
      border-radius: 14px;
      border: 1px solid #e0e0e0;
      padding: 12px;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      font-size: 15px;
      line-height: 1.6;
      box-sizing: border-box;
    }
    .modal-actions{
      margin-top: 12px;
      display:flex;
      justify-content:flex-end;
    }

    .panel-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:6px;
      min-height: 34px;
    }

    .panel-title{
      font-size:12px;
      color:#8b8b8b;
      font-weight:700;
      letter-spacing:0.01em;
    }

    .panel-actions{
      display:flex;
      align-items:center;
      flex-wrap: nowrap;
      gap:8px;
    }

    .panel-status{
      margin: 0;
      min-height: 0;
      display: none;
    }

    .output-panel.has-status .panel-status{
      display: block;
      margin: 0 0 6px;
    }

    .countries-wrap{
      position: relative;
      display: inline-flex;
    }

    .countries-menu{
      position: absolute;
      top: 40px;
      left: 0;
      min-width: 180px;
      background: #fff;
      border: 1px solid #eaeaea;
      border-radius: 12px;
      box-shadow: 0 14px 30px rgba(0,0,0,0.12);
      padding: 6px;
      display: grid;
      gap: 6px;
      z-index: 50;
    }

    .countries-item{
      text-align: left;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: transparent;
      cursor: pointer;
      font: inherit;
    }

    .countries-item:hover{
      background: rgba(0,0,0,0.04);
    }

    .countries-item.active{
      background: rgba(0,0,0,0.06);
      border-color: rgba(0,0,0,0.08);
      font-weight: 600;
    }

    .chev{
      margin-left: 6px;
      opacity: 0.6;
    }

    /* Estilos para el modo Correcci√≥n */
    .correction-mode .editor {
      grid-template-columns: 1fr 360px;
    }

    .correction-mode .output-panel {
      display: none;
    }

    .correction-mode .input-panel {
      height: var(--editor-box-h);
      flex: 0 0 auto;
      min-height: 0;
    }

    .correction-mode #inputText {
      display: none;
    }
    
    .correction-mode .input-with-corrections {
      height: 100%;
      max-height: 100%;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .correction-error {
      background: rgba(11, 87, 208, 0.15);
      border-bottom: 2px solid #0b57d0;
      cursor: pointer;
      position: relative;
      border-radius: 2px;
      padding: 0 2px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .correction-error:hover {
      background: rgba(11, 87, 208, 0.25);
    }
    
    /* Error activo resaltado */
    .correction-error.active {
      background: rgba(11, 87, 208, 0.3) !important;
      border-bottom-width: 3px;
      color: #000000 !important;
    }

    .correction-error-spelling {
      background: rgba(234, 67, 53, 0.15);
      border-bottom-color: #ea4335;
    }
    
    .correction-error-spelling.active {
      background: rgba(234, 67, 53, 0.3) !important;
      border-bottom-color: #ea4335;
      color: #000000 !important;
    }

    .correction-error-spelling:hover {
      background: rgba(234, 67, 53, 0.25);
    }

    .correction-error-punctuation {
      background: rgba(251, 188, 4, 0.15);
      border-bottom-color: #fbbc04;
    }
    
    .correction-error-punctuation.active {
      background: rgba(251, 188, 4, 0.3) !important;
      border-bottom-color: #fbbc04;
      color: #000000 !important;
    }

    .correction-error-punctuation:hover {
      background: rgba(251, 188, 4, 0.25);
    }

    .input-with-corrections {
      position: relative;
      width: 100%;
      height: 100%;
      padding: 16px;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      font-size: 16px;
      line-height: 1.6;
      border-radius: 14px;
      border: 1px solid #e0e0e0;
      background: #ffffff;
      box-sizing: border-box;
      overflow-y: auto;
      overflow-x: hidden;
      white-space: pre-wrap;
      word-wrap: break-word;
      outline: none;
      /* Scroll suave */
      scroll-behavior: smooth;
      /* Transici√≥n suave para el cambio de color */
      transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Efecto de texto atenuado cuando hay un error seleccionado (como LanguageTool) */
    .input-with-corrections.dimmed-text {
      /* No aplicar color aqu√≠, lo manejamos por l√≠nea */
    }
    
    /* Estilos para las l√≠neas de texto */
    .text-line {
      color: #000000;
      transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Cuando hay texto atenuado, las l√≠neas SIN error activo se aten√∫an */
    .input-with-corrections.dimmed-text .text-line:not(.active-line) {
      color: rgba(0, 0, 0, 0.25);
    }
    
    /* La l√≠nea con el error activo mantiene color negro */
    .input-with-corrections.dimmed-text .text-line.active-line {
      color: #000000 !important;
    }
    
    /* El error activo mantiene su color normal */
    .input-with-corrections.dimmed-text .correction-error.active {
      color: #000000 !important;
      opacity: 1;
      font-weight: normal;
    }
    
    /* Los dem√°s errores tambi√©n se aten√∫an */
    .input-with-corrections.dimmed-text .correction-error:not(.active) {
      opacity: 0.25;
      transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Scrollbar personalizado para el input editable */
    .input-with-corrections::-webkit-scrollbar {
      width: 8px;
    }
    
    .input-with-corrections::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    
    .input-with-corrections::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 10px;
    }
    
    .input-with-corrections::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }

    .input-with-corrections:focus {
      border-color: #0b57d0;
      box-shadow: 0 0 0 4px rgba(11, 87, 208, 0.05);
    }

    .input-with-corrections:empty::before {
      content: attr(data-placeholder);
      color: #888;
      pointer-events: none;
    }

    .correction-mode .paraphrase-controls {
      display: none;
    }

    .correction-panel {
      display: none;
      flex-direction: column;
      background: #f8f9fa;
      border-radius: 14px;
      border: 1px solid #e0e0e0;
      overflow: hidden;
      /* Altura m√°xima igual al editor de texto */
      max-height: var(--editor-box-h);
      /* Alinear con el inputTextCorrectable (panel-header + panel-status + margen) */
      margin-top: 46px;
    }

    .correction-mode .correction-panel {
      display: flex;
    }

    .correction-panel-header {
      padding: 16px;
      background: #fff;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }

    .correction-panel-title {
      font-size: 14px;
      font-weight: 700;
      color: #111;
      display: flex;
      align-items: center;
      gap: 8px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .correction-count {
      background: #ea4335;
      color: white;
      border-radius: 12px;
      padding: 3px 10px;
      font-size: 13px;
      font-weight: 700;
      min-width: 24px;
      text-align: center;
    }
    
    /* Ocultar el contador cuando no hay errores */
    .correction-count:empty,
    .correction-count[data-count="0"] {
      display: none;
    }
    
    /* Selector regional minimalista */
    .region-selector {
      padding: 4px 8px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background: #fff;
      color: #5f6368;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      outline: none;
    }
    
    .region-selector:hover {
      border-color: #c0c0c0;
      background: #fafafa;
    }
    
    .region-selector:focus {
      border-color: #111;
    }
    
    /* Detector de tono */
    .tone-detector {
      padding: 12px 16px;
      background: #fafafa;
      border-bottom: 1px solid #e0e0e0;
      animation: slideDown 0.3s ease;
    }
    
    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .tone-message {
      font-size: 13px;
      color: #5f6368;
      margin-bottom: 10px;
      line-height: 1.4;
    }
    
    .tone-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .tone-btn {
      padding: 6px 12px;
      border: 1px solid #e0e0e0;
      background: #fff;
      color: #202124;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    
    .tone-btn:hover {
      background: #111;
      color: #fff;
      border-color: #111;
    }
    
    .tone-btn-dismiss {
      padding: 4px 10px;
      margin-left: auto;
      font-size: 16px;
      color: #5f6368;
    }
    
    .tone-btn-dismiss:hover {
      background: #e0e0e0;
      color: #202124;
      border-color: #e0e0e0;
    }

    .correction-list {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;  /* M√°s compacto, era 10px */
      /* Scroll suave */
      scroll-behavior: smooth;
      /* Personalizar scrollbar para que se vea mejor */
    }
    
    /* Scrollbar personalizado para el panel de correcciones */
    .correction-list::-webkit-scrollbar {
      width: 8px;
    }
    
    .correction-list::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    
    .correction-list::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 10px;
    }
    
    .correction-list::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }

    .correction-item {
      background: #fff;
      border-radius: 8px;
      padding: 10px 12px;
      border: 1px solid #e0e0e0;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      /* Compacto por defecto */
    }

    .correction-item:hover {
      border-color: #0b57d0;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
    }

    .correction-item.active {
      border-color: #0b57d0;
      background: #f8fbff;
      box-shadow: 0 2px 8px rgba(11, 87, 208, 0.15);
      padding: 14px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .correction-item-header {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    /* Ocultar contenido expandido por defecto */
    .correction-item-content {
      flex: 1;
      min-width: 0;
    }
    
    /* Texto compacto de una l√≠nea */
    .correction-compact-text {
      font-size: 14px;
      color: #202124;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    /* Ocultar detalles cuando est√° colapsado */
    .correction-item:not(.active) .correction-type,
    .correction-item:not(.active) .correction-error-text,
    .correction-item:not(.active) .correction-suggestion,
    .correction-item:not(.active) .correction-actions {
      display: none;
    }
    
    /* Mostrar solo texto compacto cuando est√° colapsado */
    .correction-item.active .correction-compact-text {
      display: none;
    }

    .correction-icon {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .correction-icon-spelling {
      background: #ea4335;
    }

    .correction-icon-punctuation {
      background: #fbbc04;
    }

    .correction-type {
      font-size: 11px;
      font-weight: 600;
      color: #5f6368;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .correction-error-text {
      font-size: 14px;
      color: #202124;
      font-weight: 400;
      margin-bottom: 8px;
      word-break: break-word;
      line-height: 1.4;
    }

    .correction-error-word {
      color: #ea4335;
      font-weight: 600;
      background: rgba(234, 67, 53, 0.1);
      padding: 2px 4px;
      border-radius: 4px;
    }

    .correction-suggestion-text {
      font-size: 13px;
      color: #5f6368;
      margin-bottom: 10px;
      line-height: 1.4;
    }

    .correction-suggestion {
      background: #e8f0fe;
      color: #0b57d0;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      display: inline-block;
      margin-bottom: 8px;
      margin-right: 6px;
      word-break: break-word;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .correction-suggestion:hover {
      background: #d2e3fc;
    }

    .correction-actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .correction-btn {
      padding: 6px 12px;
      border: 1px solid #dadce0;
      background: #fff;
      color: #5f6368;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s ease;
      font-weight: 500;
    }

    .correction-btn:hover {
      background: #f8f9fa;
      border-color: #c1c1c1;
    }
      transition: background 0.2s ease;
    }

    .correction-suggestion:hover {
      background: #d2e3fc;
    }

    .correction-actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .correction-btn {
      flex: 1;
      padding: 8px 14px;
      border-radius: 8px;
      border: 1px solid #dadce0;
      background: #fff;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .correction-btn:hover {
      background: #f8f9fa;
      border-color: #5f6368;
    }

    .correction-btn-accept {
      background: #0b57d0;
      color: white;
      border-color: #0b57d0;
    }

    .correction-btn-accept:hover {
      background: #094ba8;
    }
    
    /* Smart Replace - minimalista */
    .smart-replace {
      margin: 10px 0 8px 0;
      padding-top: 8px;
      border-top: 1px solid #f0f0f0;
    }
    
    .smart-replace-trigger {
      font-size: 12px;
      color: #5f6368;
      cursor: pointer;
      display: inline-block;
      padding: 4px 0;
      transition: color 0.2s ease;
    }
    
    .smart-replace-trigger:hover {
      color: #202124;
      text-decoration: underline;
    }
    
    .smart-replace-results {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }
    
    .synonym-chip {
      padding: 4px 10px;
      background: #f8f8f8;
      border: 1px solid #e8e8e8;
      border-radius: 12px;
      font-size: 12px;
      color: #202124;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .synonym-chip:hover {
      background: #202124;
      color: #fff;
      border-color: #202124;
    }
    
    /* Traductor - ultra minimalista */
    .translation-bar {
      margin: 10px 0 8px 0;
      padding-top: 8px;
      border-top: 1px solid #f0f0f0;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .translation-trigger {
      padding: 3px 8px;
      background: #fafafa;
      border: 1px solid #e8e8e8;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      color: #5f6368;
      cursor: pointer;
      transition: all 0.2s ease;
      letter-spacing: 0.3px;
    }
    
    .translation-trigger:hover {
      background: #202124;
      color: #fff;
      border-color: #202124;
    }
    
    .translation-result {
      font-size: 12px;
      color: #202124;
      padding: 4px 8px;
      background: #fafafa;
      border-radius: 4px;
      flex: 1;
      min-width: 100px;
      display: none;
    }
    
    .translation-result.visible {
      display: block;
    }

    .correction-btn-accept:hover {
      background: #0842a0;
      border-color: #0842a0;
    }

    .correction-item-ignored {
      opacity: 0.4;
      pointer-events: none;
    }

    .no-corrections {
      text-align: center;
      padding: 48px 16px;
      color: #5f6368;
      font-size: 14px;
    }

    .no-corrections-icon {
      font-size: 48px;
      margin-bottom: 12px;
      opacity: 0.5;
    }

  </style>
</head>
<body>
  <div class="page">
    <div class="container">
      <div class="header">
        <div class="header-left">
          <h1>para</h1>
          <p class="subtitle">transform your text</p>
        </div>
        <button id="historyBtn" class="history-btn" type="button">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          Historial
        </button>
      </div>

      <div id="editorPanel" class="tab-panel active">
        <div class="modes" id="modeControls"></div>
        <p id="modeHelp" class="mode-help" aria-live="polite"></p>

        <div class="editor">
          <div>
            <div class="panel-header">
              <div class="panel-title">Entrada</div>
            </div>
            <div class="panel-status" aria-hidden="true"></div>
            <div class="input-panel">
              <textarea id="inputText" placeholder="Ingresa el texto que quieres parafrasear..."></textarea>
              <div id="inputTextCorrectable" class="input-with-corrections" contenteditable="true" style="display: none;" data-placeholder="Escribe o pega tu texto aqu√≠ para revisar ortograf√≠a y gram√°tica..."></div>
              <button id="copyInput" class="copy-btn" type="button" aria-label="Copiar entrada">Copiar</button>
            </div>
            <div class="controls paraphrase-controls">
              <button id="paraphrase">Humanizar</button>
            </div>
            <div id="inputCharCount" class="meta">0 caracteres</div>
          </div>

          <div class="output-panel">
            <div class="panel-header">
              <div class="panel-title">Salida</div>

              <div class="panel-actions">
                <button id="toggleInput" class="secondary-btn" type="button">Ocultar entrada</button>

                <button id="toggleChanges" type="button" class="secondary-btn" disabled>Ver cambios</button>

                <div class="translate-wrap">
                  <button id="translateBtn" class="secondary-btn" type="button" disabled>Traducir</button>
                  <div id="translateMenu" class="translate-menu" hidden>
                    <button type="button" data-lang="en">üá∫üá∏ Ingl√©s</button>
                    <button type="button" data-lang="fr">üá´üá∑ Franc√©s</button>
                    <button type="button" data-lang="de">üá©üá™ Alem√°n</button>
                    <button type="button" data-lang="pt">üáµüáπ Portugu√©s</button>
                  </div>
                </div>

                <div class="kebab-wrap">
                  <button id="outputMenuBtn" class="kebab-btn" type="button" aria-label="M√°s opciones" aria-haspopup="true" aria-expanded="false">‚ãØ</button>

                  <div id="outputMenu" class="kebab-menu" role="menu" hidden>
                    <button id="menuDownloadPdf" type="button" role="menuitem" class="kebab-item" disabled>Descargar PDF</button>
                    <button id="menuDownloadDocx" type="button" role="menuitem" class="kebab-item" disabled>Descargar Word</button>
                  </div>
                </div>
              </div>
            </div>

            <div class="panel-status">
              <span id="toggleStatus" class="status-label"></span>
            </div>

            <div id="translateBanner" class="translate-banner" hidden>
              <div class="translate-banner-left">
                <span>üåê</span>
                <span id="translateBannerText">Traducido a Ingl√©s</span>
              </div>
              <button id="translateBannerClose" type="button">Volver al original</button>
            </div>

            <div class="output-box">
              <div
                id="outputText"
                class="output"
                data-placeholder="Aqu√≠ aparecer√° el texto parafraseado"
                contenteditable="true"
              ></div>

              <button id="copyOutput" class="copy-btn" type="button" aria-label="Copiar salida">Copiar</button>
            </div>
            <div id="outputCharCount" class="meta"></div>
            <div id="similarityText" class="meta"></div>
          </div>

          <!-- Panel de correcciones -->
          <div class="correction-panel" id="correctionPanel">
            <div class="correction-panel-header">
              <div class="correction-panel-title">
                Corregir
                <span class="correction-count" id="correctionCount">0</span>
              </div>
              
              <!-- Selector regional minimalista -->
              <select id="regionSelector" class="region-selector" title="Variante regional">
                <option value="neutral">Neutro</option>
                <option value="es">Espa√±a</option>
                <option value="mx">M√©xico</option>
                <option value="ar">Argentina</option>
                <option value="co">Colombia</option>
                <option value="cl">Chile</option>
              </select>
            </div>
            
            <!-- Detector de tono (oculto por defecto) -->
            <div class="tone-detector" id="toneDetector" style="display: none;">
              <div class="tone-message" id="toneMessage"></div>
              <div class="tone-actions">
                <button class="tone-btn" data-action="formal">Unificar formal</button>
                <button class="tone-btn" data-action="informal">Unificar informal</button>
                <button class="tone-btn tone-btn-dismiss" data-action="dismiss">√ó</button>
              </div>
            </div>
            
            <div class="correction-list" id="correctionList">
              <div class="no-corrections">
                <div class="no-corrections-icon">‚úì</div>
                <div>No se encontraron errores</div>
              </div>
            </div>
          </div>
        </div>

      </div>

    </div>
  </div>

  <div id="historyModal" class="history-modal" hidden>
    <div class="history-modal-content">
      <div class="history-modal-header">
        <h2 class="history-modal-title">Historial</h2>
        <button id="historyClose" class="history-close" type="button" aria-label="Cerrar">‚úï</button>
      </div>
      <div class="history-modal-body">
        <p class="subtitle" style="margin-bottom:16px;">√öltimas 10 par√°frasis guardadas localmente</p>
        <ul id="historyList" class="history-list"></ul>
      </div>
    </div>
  </div>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.11.0/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/3.0.3/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js"></script>

  <script>
    const MODES = [
      { key: "correccion", label: "Correcci√≥n", help: "Detecta y corrige errores de ortograf√≠a y puntuaci√≥n." },
      { key: "humanizar", label: "Humanizar", help: "M√°s natural y menos repetitivo." },
      { key: "academico", label: "Acad√©mico", help: "Formal y objetivo." },
      { key: "resumir", label: "Resumir", help: "M√°s corto, conserva lo esencial." },
      { key: "creativo", label: "Creativo", help: "M√°s fluido y con estilo." },
      { key: "simplificar", label: "Simplificar", help: "Explica f√°cil, frases cortas." },
      { key: "chilenizar", label: "Chilenizar", help: "Espa√±ol de Chile (sutil, sin caricatura)." },
      { key: "mexicanizar", label: "Mexicanizar", help: "Espa√±ol de M√©xico (sutil, sin caricatura)." },
      { key: "argentinizar", label: "Argentinizar", help: "Espa√±ol de Argentina (sutil, sin caricatura)." },
      { key: "espanolizar", label: "Espa√±olizar", help: "Espa√±ol de Espa√±a (sutil, sin caricatura)." }
    ];
    let currentMode = "correccion";
    const allowedModes = MODES.map(mode => mode.key);
    const MODE_LABELS = Object.fromEntries(MODES.map(mode => [mode.key, mode.label]));
    const MODE_HELP = Object.fromEntries(MODES.map(mode => [mode.key, mode.help]));
    const MODE_LOADING = {
      correccion: "Corrigiendo‚Ä¶",
      humanizar: "Humanizando‚Ä¶",
      academico: "Redactando‚Ä¶",
      resumir: "Resumiendo‚Ä¶",
      creativo: "Creando‚Ä¶",
      simplificar: "Simplificando‚Ä¶",
      chilenizar: "Chilenizando‚Ä¶",
      mexicanizar: "Mexicanizando‚Ä¶",
      argentinizar: "Argentinizando‚Ä¶",
      espanolizar: "Espa√±olizando‚Ä¶"
    };
    const DIFF_TOKEN_LIMIT = 4000;
    const COUNTRY_MODE_KEYS = ["chilenizar", "mexicanizar", "argentinizar", "espanolizar"];
    const COUNTRY_MODE_LABELS = Object.freeze({
      chilenizar: "Chilenizar",
      mexicanizar: "Mexicanizar",
      argentinizar: "Argentinizar",
      espanolizar: "Espa√±olizar"
    });
    const HISTORY_KEY = "para.history.v1";
    const HISTORY_MAX_ITEMS = 10;
    const MAX_DROP_FILE_SIZE = 5 * 1024 * 1024;

    let diffViewEnabled = false;
    let diffButtonBlocked = true;
    let isManualEdited = false;
    let isProgrammaticUpdate = false;
    let hasReceivedFirstChunk = false;
    let currentOriginalText = "";
    let currentResultText = "";
    let currentDiff = null;
    let synonymPopover = null;
    let synonymAnchor = null;
    let synonymController = null;
    const synonymCache = new Map();

    function escapeHtml(str) {
      if (typeof str !== "string") return "";
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function tokenize(text) {
      return text.match(/\p{L}[\p{L}\p{N}_'-]*|\p{N}+|[^\s\p{L}\p{N}]|\s+/gu) || [];
    }

    function shouldJoinWithoutSpace(prev, curr) {
      if (!prev || !curr) return false;
      if (/^\s+$/.test(curr) || /^\s+$/.test(prev)) return false;

      const closers = /^[.,;:!?%)\]¬ª‚Äù‚Äô]+$/;
      const openers = /^[(\[{¬´‚Äú‚Äò¬ø¬°]+$/;
      const apostropheLike = /^[‚Äô']$/;

      return closers.test(curr) || openers.test(prev) || apostropheLike.test(curr) || apostropheLike.test(prev);
    }

    function joinTokens(tokens) {
      let text = "";
      tokens.forEach((token, index) => {
        if (!token) return;
        if (text && !shouldJoinWithoutSpace(tokens[index - 1], token)) {
          text += " ";
        }
        text += token;
      });
      return text;
    }

    function renderTokens(tokens, mode) {
      let html = "";
      const punctuationTokenRegex = /^[.,;:!?]+$/;
      tokens.forEach((token, i) => {
        if (!token?.value) return;

        const escaped = escapeHtml(token.value);
        let wrapped = escaped;

        if (mode === "simple") {
          if (token.type === "removed") return;
          if (token.type === "added") {
            const clickable = isEligibleSynonymToken(token.value);
            if (clickable) {
              const outIndexAttr = Number.isInteger(token.outIndex) ? ` data-out-index="${token.outIndex}"` : "";
              wrapped = `<span class="added syn-word"${outIndexAttr} data-token="${escaped}">${escaped}</span>`;
            } else {
              wrapped = `<span class="added">${escaped}</span>`;
            }
          }
        } else if (mode === "diff") {
          if (token.type === "added") {
            const clickable = isEligibleSynonymToken(token.value);
            if (clickable) {
              const outIndexAttr = Number.isInteger(token.outIndex) ? ` data-out-index="${token.outIndex}"` : "";
              wrapped = `<span class="diff-added syn-word"${outIndexAttr} data-token="${escaped}">${escaped}</span>`;
            } else {
              wrapped = `<span class="diff-added">${escaped}</span>`;
            }
          } else if (token.type === "removed") {
            wrapped = `<span class="diff-removed">${escaped}</span>`;
          }
        }

        const isPunctuationToken = punctuationTokenRegex.test(token.value);
        if (isPunctuationToken && /<\/span>$/.test(html)) {
          html = html.replace(/<\/span>$/, `${escaped}</span>`);
          return;
        }

        if (html.length > 0 && !isPunctuationToken && !shouldJoinWithoutSpace(tokens[i - 1]?.value, token.value)) {
          html += " ";
        }

        html += wrapped;
      });

      return html;
    }

    function buildDiffData(originalText, paraphrasedText) {
      const origTokens = tokenize(originalText).filter(t => !/^\s+$/.test(t));
      const outTokens = tokenize(paraphrasedText).filter(t => !/^\s+$/.test(t));

      if (!outTokens.length) {
        return { tokens: [], outTokens: [], addedCount: 0, totalCount: 0, diffDisabled: false };
      }

      if (origTokens.length + outTokens.length > DIFF_TOKEN_LIMIT) {
        return {
          tokens: outTokens.map((token, idx) => ({ value: token, type: "equal", outIndex: idx })),
          outTokens,
          addedCount: 0,
          totalCount: outTokens.length,
          diffDisabled: true
        };
      }

      const n = origTokens.length;
      const m = outTokens.length;
      const dp = Array.from({ length: n + 1 }, () => new Uint16Array(m + 1));

      for (let i = n - 1; i >= 0; i--) {
        for (let j = m - 1; j >= 0; j--) {
          if (origTokens[i] === outTokens[j]) {
            dp[i][j] = dp[i + 1][j + 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
          }
        }
      }

      const tokens = [];
      let i = 0;
      let j = 0;

      while (i < n && j < m) {
        if (origTokens[i] === outTokens[j]) {
          tokens.push({ value: outTokens[j], type: "equal", outIndex: j });
          i++;
          j++;
        } else if (dp[i][j + 1] >= dp[i + 1][j]) {
          tokens.push({ value: outTokens[j], type: "added", outIndex: j });
          j++;
        } else {
          tokens.push({ value: origTokens[i], type: "removed" });
          i++;
        }
      }

      while (i < n) {
        tokens.push({ value: origTokens[i], type: "removed" });
        i++;
      }

      while (j < m) {
        tokens.push({ value: outTokens[j], type: "added", outIndex: j });
        j++;
      }

      const addedCount = tokens.filter(token => token.type === "added").length;
      const totalCount = tokens.filter(token => token.type !== "removed").length;

      return { tokens, outTokens, addedCount, totalCount, diffDisabled: false };
    }

    const modeControls = document.getElementById("modeControls");
    const modeHelp = document.getElementById("modeHelp");
    const input = document.getElementById("inputText");
    const inputText = input;
    const output = document.getElementById("outputText");
    const editor = document.querySelector(".editor");
    const btn = document.getElementById("paraphrase");
    const copyInputBtn = document.getElementById("copyInput");
    const copyBtn = document.getElementById("copyOutput");
    const outputMenuBtn = document.getElementById("outputMenuBtn");
    const outputMenu = document.getElementById("outputMenu");
    const menuDownloadPdf = document.getElementById("menuDownloadPdf");
    const menuDownloadDocx = document.getElementById("menuDownloadDocx");
    const translateBtn = document.getElementById("translateBtn");
    const translateMenu = document.getElementById("translateMenu");
    const translateBanner = document.getElementById("translateBanner");
    const translateBannerText = document.getElementById("translateBannerText");
    const translateBannerClose = document.getElementById("translateBannerClose");
    const inputCharCount = document.getElementById("inputCharCount");
    const outputCharCount = document.getElementById("outputCharCount");
    const similarityText = document.getElementById("similarityText");
    const toggleChanges = document.getElementById("toggleChanges");
    const toggleStatus = document.getElementById("toggleStatus");
    const outputPanelEl = document.querySelector(".output-panel");
    const toggleInputBtn = document.getElementById("toggleInput");

    // Translation state
    let currentTranslation = null; // { lang, text, original }
    let isTranslated = false;

    function syncStatusVisibility() {
      if (!outputPanelEl || !toggleStatus) return;
      const has = (toggleStatus.textContent || "").trim().length > 0;
      outputPanelEl.classList.toggle("has-status", has);
    }
    const historyList = document.getElementById("historyList");
    let inputHidden = false;

    function renderModeControls() {
      modeControls.innerHTML = `
        ${MODES.filter(mode => !COUNTRY_MODE_KEYS.includes(mode.key)).map(mode => `
          <button type="button" class="mode-btn" data-mode="${mode.key}">${mode.label}</button>
        `).join("")}
        <div class="countries-wrap">
          <button id="countriesBtn" class="mode-btn" type="button" aria-haspopup="true" aria-expanded="false">
            Pa√≠ses <span class="chev">‚ñæ</span>
          </button>

          <div id="countriesMenu" class="countries-menu" role="menu" hidden>
            ${COUNTRY_MODE_KEYS.map((key) => `<button type="button" class="countries-item" data-mode="${key}" role="menuitem">${COUNTRY_MODE_LABELS[key]}</button>`).join("")}
          </div>
        </div>
      `;

      modeControls.querySelectorAll(".mode-btn[data-mode]").forEach((btnMode) => {
        btnMode.addEventListener("click", () => {
          setActiveMode(btnMode.dataset.mode);
        });
      });

      const countriesBtn = document.getElementById("countriesBtn");
      const countriesMenu = document.getElementById("countriesMenu");

      if (countriesBtn && countriesMenu) {
        countriesBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          const isHidden = countriesMenu.hasAttribute("hidden");
          if (isHidden) countriesMenu.removeAttribute("hidden");
          else countriesMenu.setAttribute("hidden", "");
          countriesBtn.setAttribute("aria-expanded", isHidden ? "true" : "false");
        });

        countriesMenu.querySelectorAll(".countries-item").forEach((countryButton) => {
          countryButton.addEventListener("click", (e) => {
            e.stopPropagation();
            const mode = countryButton.getAttribute("data-mode");
            setActiveMode(mode);
            countriesMenu.setAttribute("hidden", "");
            countriesBtn.setAttribute("aria-expanded", "false");
          });
        });

        document.addEventListener("click", () => {
          if (!countriesMenu.hasAttribute("hidden")) {
            countriesMenu.setAttribute("hidden", "");
            countriesBtn.setAttribute("aria-expanded", "false");
          }
        });
      }
    }

    function syncCountriesUI(activeMode) {
      const countriesBtn = document.getElementById("countriesBtn");
      const countriesMenu = document.getElementById("countriesMenu");
      if (!countriesBtn || !countriesMenu) return;

      countriesMenu.querySelectorAll(".countries-item").forEach((el) => {
        el.classList.toggle("active", el.getAttribute("data-mode") === activeMode);
      });

      if (COUNTRY_MODE_LABELS[activeMode]) {
        countriesBtn.innerHTML = `Pa√≠ses: ${COUNTRY_MODE_LABELS[activeMode]} <span class="chev">‚ñæ</span>`;
      } else {
        countriesBtn.innerHTML = `Pa√≠ses <span class="chev">‚ñæ</span>`;
      }
    }

    function setParaphraseLabel(isLoading) {
      const actionLabel = MODE_LABELS[currentMode] || "Humanizar";
      const loadingLabel = MODE_LOADING[currentMode] || `${actionLabel}‚Ä¶`;
      btn.textContent = isLoading ? loadingLabel : actionLabel;
    }

    function getSimilarityLabel(similarity) {
      if (similarity >= 80) return "Cambios leves";
      if (similarity >= 60) return "Cambios moderados";
      return "Reescritura profunda";
    }

    function setOutputHtml(html) {
      isProgrammaticUpdate = true;
      output.innerHTML = html;
      isProgrammaticUpdate = false;
    }

    function getVisibleOutputText() {
      return (output.textContent || "").trim();
    }

    function updateExportButtons() {
      const hasOutput = Boolean(getVisibleOutputText());
      menuDownloadPdf.disabled = !hasOutput;
      menuDownloadDocx.disabled = !hasOutput;
      translateBtn.disabled = !hasOutput;

      copyBtn.hidden = !hasOutput;
      outputMenuBtn.hidden = !hasOutput;
      toggleChanges.hidden = !hasOutput;
      translateBtn.hidden = !hasOutput;

      if (!hasOutput) {
        outputMenu.hidden = true;
        outputMenuBtn.setAttribute("aria-expanded", "false");
        toggleStatus.textContent = "";
        syncStatusVisibility();
      }
    }

    function disableDiffButton(message = "") {
      diffButtonBlocked = true;
      diffViewEnabled = false;
      toggleChanges.classList.remove("active");
      toggleChanges.setAttribute("aria-pressed", "false");
      toggleChanges.disabled = true;
      toggleStatus.textContent = message;
      syncStatusVisibility();
    }

    function enableDiffButton(message = "") {
      diffButtonBlocked = false;
      toggleChanges.disabled = false;
      toggleStatus.textContent = message;
      syncStatusVisibility();
    }

    function applyOutputView() {
      if (!currentDiff) {
        setOutputHtml(escapeHtml(currentResultText));
      } else {
        const mode = diffViewEnabled ? "diff" : "simple";
        setOutputHtml(renderTokens(currentDiff.tokens, mode));
      }
      toggleChanges.classList.toggle("active", diffViewEnabled);
      toggleChanges.setAttribute("aria-pressed", diffViewEnabled ? "true" : "false");
      updateExportButtons();
    }

    function updateInputCount() {
      inputCharCount.textContent = `${input.value.length} caracteres`;
    }

    function setActiveMode(mode) {
      const nextMode = allowedModes.includes(mode) ? mode : "correccion";
      const previousMode = currentMode;
      currentMode = nextMode;
      modeControls.querySelectorAll(".mode-btn[data-mode]").forEach(button => button.classList.toggle("active", button.dataset.mode === nextMode));
      syncCountriesUI(nextMode);
      modeHelp.textContent = MODE_HELP[nextMode] || MODE_HELP.correccion;
      if (!btn.disabled) setParaphraseLabel(false);
      
      // Toggle correction mode class on editor
      const editorPanel = document.getElementById('editorPanel');
      if (editorPanel) {
        const isCorrectionMode = nextMode === 'correccion';
        const wasCorrectionMode = previousMode === 'correccion';
        
        editorPanel.classList.toggle('correction-mode', isCorrectionMode);
        
        // Si cambiamos a o desde modo correcci√≥n, toggle los elementos
        if (isCorrectionMode !== wasCorrectionMode) {
          toggleCorrectionMode(isCorrectionMode);
        }
      }
    }

    function saveHistoryEntry(entry) {
      const items = loadHistory();
      items.unshift(entry);
      localStorage.setItem(HISTORY_KEY, JSON.stringify(items.slice(0, HISTORY_MAX_ITEMS)));
      renderHistory();
    }

    function loadHistory() {
      try {
        const parsed = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]");
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function formatTimestamp(value) {
      return new Date(value).toLocaleString("es-ES", { dateStyle: "short", timeStyle: "short" });
    }

    function renderHistory() {
      const items = loadHistory();
      historyList.innerHTML = "";

      if (!items.length) {
        historyList.innerHTML = '<li class="history-item" style="cursor:default;"><p class="history-item-title">A√∫n no hay historial</p><p class="history-item-text">Las par√°frasis recientes aparecer√°n aqu√≠.</p></li>';
        return;
      }

      items.forEach((item) => {
        const safeResult = typeof item.result === "string" ? item.result : "";
        const safeMode = allowedModes.includes(item.mode) ? item.mode : "humanizar";
        const safeOriginal = typeof item.original === "string" ? item.original : "";
        const modeLabel = MODE_LABELS[safeMode] || safeMode;

        const li = document.createElement("li");
        li.className = "history-item";
        li.innerHTML = `
          <p class="history-item-title">${escapeHtml(formatTimestamp(item.timestamp))} ¬∑ ${escapeHtml(modeLabel)}</p>
          <p class="history-item-text">${escapeHtml(safeResult.slice(0, 160))}${safeResult.length > 160 ? "‚Ä¶" : ""}</p>
        `;

        li.addEventListener("click", () => {
          input.value = safeOriginal;
          updateInputCount();
          setActiveMode(safeMode);

          currentOriginalText = safeOriginal;
          currentResultText = safeResult;
          currentDiff = buildDiffData(currentOriginalText, currentResultText);

          isManualEdited = false;
          diffViewEnabled = false;
          applyOutputView();

          if (currentDiff.diffDisabled) {
            disableDiffButton("Cambios no disponibles por longitud del texto");
          } else {
            enableDiffButton("");
          }

          outputCharCount.textContent = `${safeResult.length} caracteres`;
          const similarity = currentDiff.totalCount
            ? Math.round(100 - (currentDiff.addedCount / currentDiff.totalCount) * 100)
            : 100;
          similarityText.textContent = getSimilarityLabel(similarity);
          closeHistoryModal();
        });

        historyList.appendChild(li);
      });
    }

    function showSkeleton() {
      const html = `
        <div class="skeleton" aria-hidden="true">
          <div class="skeleton-line"></div>
          <div class="skeleton-line"></div>
          <div class="skeleton-line"></div>
          <div class="skeleton-line"></div>
        </div>
      `;
      setOutputHtml(html);
    }

    function isEligibleSynonymToken(word) {
      if (!word || word.length < 2 || word.length > 40) return false;
      if (!/[\p{L}]/u.test(word)) return false;
      if (/^\d+(?:[.,]\d+)?$/.test(word)) return false;
      if (/^[A-Z√Å√â√ç√ì√ö√ë][a-z√°√©√≠√≥√∫√±]+(?:[A-Z√Å√â√ç√ì√ö√ë][a-z√°√©√≠√≥√∫√±]+)*$/.test(word)) return false;
      if (/^(https?:\/\/|www\.)/i.test(word)) return false;
      if (/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(word)) return false;
      return true;
    }

    function closeSynonymPopover() {
      if (synonymController) {
        synonymController.abort();
        synonymController = null;
      }
      if (synonymPopover) {
        synonymPopover.remove();
        synonymPopover = null;
      }
      synonymAnchor = null;
    }

    function openSynonymPopover(anchor) {
      closeSynonymPopover();
      synonymAnchor = anchor;
      const rect = anchor.getBoundingClientRect();
      const popover = document.createElement("div");
      popover.className = "synonym-popover";
      popover.style.left = `${Math.min(window.innerWidth - 280, Math.max(8, rect.left))}px`;
      popover.style.top = `${Math.min(window.innerHeight - 120, rect.bottom + 8)}px`;
      popover.innerHTML = '<div class="synonym-loading">Cargando‚Ä¶</div>';
      document.body.appendChild(popover);
      synonymPopover = popover;
      return popover;
    }

    function applyCapitalization(sourceWord, replacementWord) {
      if (!sourceWord || !replacementWord) return replacementWord;
      if (/^[A-Z√Å√â√ç√ì√ö√ë]/.test(sourceWord)) {
        return replacementWord.charAt(0).toUpperCase() + replacementWord.slice(1);
      }
      return replacementWord;
    }

    async function fetchSynonyms(word, context) {
      const key = `${word.toLowerCase()}|${context}`;
      if (synonymCache.has(key)) return synonymCache.get(key);

      synonymController = new AbortController();
      try {
        const response = await fetch("/api/synonyms", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ word, context, mode: currentMode }),
          signal: synonymController.signal
        });
        const data = await response.json().catch(() => ({ synonyms: [] }));
        const synonyms = Array.isArray(data.synonyms) ? data.synonyms.slice(0, 4) : [];
        synonymCache.set(key, synonyms);
        return synonyms;
      } catch {
        return [];
      } finally {
        synonymController = null;
      }
    }

    async function onSynWordClick(event) {
      const target = event.target.closest(".syn-word");
      if (!target || !output.contains(target) || !currentDiff?.outTokens?.length) return;
      const outIndex = Number.parseInt(target.dataset.outIndex, 10);
      if (!Number.isInteger(outIndex) || outIndex < 0 || outIndex >= currentDiff.outTokens.length) return;

      const currentWord = currentDiff.outTokens[outIndex];
      if (!isEligibleSynonymToken(currentWord)) {
        const pop = openSynonymPopover(target);
        pop.innerHTML = '<div class="synonym-empty">Sin alternativas √∫tiles</div>';
        return;
      }

      if (synonymAnchor === target && synonymPopover) {
        closeSynonymPopover();
        return;
      }

      const popover = openSynonymPopover(target);
      const context = joinTokens(currentDiff.outTokens.slice(Math.max(0, outIndex - 15), outIndex + 16)).slice(0, 900);
      const synonyms = await fetchSynonyms(currentWord, context);
      if (!synonymPopover || synonymAnchor !== target) return;

      if (!synonyms.length) {
        popover.innerHTML = '<div class="synonym-empty">Sin alternativas √∫tiles</div>';
        return;
      }

      popover.innerHTML = "";
      synonyms.forEach((synonym) => {
        const optionButton = document.createElement("button");
        optionButton.type = "button";
        optionButton.textContent = synonym;
        optionButton.addEventListener("click", () => {
          const outTokens = [...currentDiff.outTokens];
          outTokens[outIndex] = applyCapitalization(currentWord, synonym);
          currentResultText = joinTokens(outTokens);
          currentDiff = buildDiffData(currentOriginalText, currentResultText);
          diffViewEnabled = false;
          applyOutputView();
          outputCharCount.textContent = `${currentResultText.length} caracteres`;
          const similarity = currentDiff.totalCount
            ? Math.round(100 - (currentDiff.addedCount / currentDiff.totalCount) * 100)
            : 100;
          similarityText.textContent = getSimilarityLabel(similarity);
          closeSynonymPopover();
        });
        popover.appendChild(optionButton);
      });
    }

    function clearOutputState() {
      currentOriginalText = "";
      currentResultText = "";
      currentDiff = null;
      diffViewEnabled = false;
      isManualEdited = false;
      setOutputHtml("");
      outputCharCount.textContent = "";
      similarityText.textContent = "";
      disableDiffButton("");
      toggleStatus.textContent = "";
      syncStatusVisibility();
      updateExportButtons();
      closeSynonymPopover();
    }

    async function extractFileText(file) {
      if (!file) return "";
      const name = file.name.toLowerCase();
      if (file.size > MAX_DROP_FILE_SIZE) {
        throw new Error("El archivo supera el l√≠mite de 5MB.");
      }
      if (name.endsWith(".txt")) {
        return await file.text();
      }
      if (name.endsWith(".docx")) {
        if (!window.mammoth) throw new Error("No se pudo cargar Mammoth para leer DOCX.");
        const arrayBuffer = await file.arrayBuffer();
        const result = await window.mammoth.extractRawText({ arrayBuffer });
        return result.value || "";
      }
      throw new Error("Solo se admiten archivos .txt o .docx.");
    }

    async function handleDroppedFile(file) {
      try {
        const text = await extractFileText(file);
        if (!text.trim()) {
          setOutputHtml("El archivo no contiene texto legible.");
          return;
        }
        input.value = text;
        updateInputCount();
        clearOutputState();
      } catch (error) {
        setOutputHtml(escapeHtml(error.message || "No se pudo leer el archivo."));
      }
    }

    function installDragAndDrop() {
      let dragDepth = 0;
      const activateDrop = () => {
        editor.classList.add("drop-active");
        input.classList.add("drop-active");
      };
      const clearDrop = () => {
        editor.classList.remove("drop-active");
        input.classList.remove("drop-active");
      };

      const onDragOver = (event) => {
        event.preventDefault();
        event.dataTransfer.dropEffect = "copy";
      };

      [editor, input].forEach((el) => {
        el.addEventListener("dragenter", (event) => {
          event.preventDefault();
          dragDepth += 1;
          activateDrop();
        });
        el.addEventListener("dragover", onDragOver);
        el.addEventListener("dragleave", (event) => {
          event.preventDefault();
          dragDepth = Math.max(0, dragDepth - 1);
          if (!dragDepth) clearDrop();
        });
        el.addEventListener("drop", async (event) => {
          event.preventDefault();
          dragDepth = 0;
          clearDrop();
          const file = event.dataTransfer?.files?.[0];
          if (file) await handleDroppedFile(file);
        });
      });
    }

    function downloadPdf() {
      const text = getVisibleOutputText();
      if (!text || !window.jspdf?.jsPDF) return;
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit: "pt", format: "a4" });
      const margin = 48;
      const pageWidth = doc.internal.pageSize.getWidth() - margin * 2;
      const pageHeight = doc.internal.pageSize.getHeight() - margin * 2;
      const lines = doc.splitTextToSize(text, pageWidth);
      let y = margin;
      doc.setFontSize(12);
      lines.forEach((line) => {
        if (y > margin + pageHeight) {
          doc.addPage();
          y = margin;
        }
        doc.text(line, margin, y);
        y += 18;
      });
      doc.save("para.pdf");
    }

    async function downloadDocx() {
      const text = getVisibleOutputText();
      if (!text || !window.docx) return;
      const { Document, Packer, Paragraph, TextRun } = window.docx;
      const paragraphs = text.split(/\n+/).map(line => new Paragraph({ children: [new TextRun(line)] }));
      const doc = new Document({ sections: [{ children: paragraphs.length ? paragraphs : [new Paragraph("")] }] });
      const blob = await Packer.toBlob(doc);
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "para.docx";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    renderModeControls();
    setActiveMode(currentMode);
    syncStatusVisibility();
    setParaphraseLabel(false);
    updateInputCount();
    renderHistory();
    updateExportButtons();
    installDragAndDrop();

    input.addEventListener("input", updateInputCount);

    // History modal functionality
    const historyBtn = document.getElementById("historyBtn");
    const historyModal = document.getElementById("historyModal");
    const historyClose = document.getElementById("historyClose");

    function openHistoryModal() {
      historyModal.hidden = false;
      renderHistory();
    }

    function closeHistoryModal() {
      historyModal.hidden = true;
    }

    historyBtn.addEventListener("click", openHistoryModal);
    historyClose.addEventListener("click", closeHistoryModal);
    
    historyModal.addEventListener("click", (e) => {
      if (e.target === historyModal) closeHistoryModal();
    });

    toggleChanges.addEventListener("click", () => {
      if (diffButtonBlocked || !currentDiff || isManualEdited) return;
      diffViewEnabled = !diffViewEnabled;
      applyOutputView();
    });

    if (toggleInputBtn && editor) {
      toggleInputBtn.addEventListener("click", () => {
        inputHidden = !inputHidden;
        editor.classList.toggle("hide-input", inputHidden);
        toggleInputBtn.textContent = inputHidden ? "Mostrar entrada" : "Ocultar entrada";
      });
    }

    output.addEventListener("click", onSynWordClick);

    function openOutputMenu() {
      outputMenu.hidden = false;
      outputMenuBtn.setAttribute("aria-expanded", "true");
    }

    function closeOutputMenu() {
      outputMenu.hidden = true;
      outputMenuBtn.setAttribute("aria-expanded", "false");
    }

    function openTranslateMenu() {
      translateMenu.hidden = false;
      // Highlight current language if translated
      if (isTranslated && currentTranslation) {
        translateMenu.querySelectorAll("button").forEach(btn => {
          btn.classList.toggle("active", btn.dataset.lang === currentTranslation.lang);
        });
      }
    }

    function closeTranslateMenu() {
      translateMenu.hidden = true;
    }

    function showTranslateBanner(langCode) {
      const labels = { en: "Ingl√©s", fr: "Franc√©s", de: "Alem√°n", pt: "Portugu√©s" };
      translateBannerText.textContent = `Traducido a ${labels[langCode] || langCode}`;
      translateBanner.hidden = false;
    }

    function hideTranslateBanner() {
      translateBanner.hidden = true;
    }

    function restoreOriginalText() {
      if (currentTranslation && currentTranslation.original) {
        setOutputHtml(escapeHtml(currentTranslation.original));
        isTranslated = false;
        hideTranslateBanner();
        outputCharCount.textContent = `${currentTranslation.original.length} caracteres`;
      }
    }

    async function translateToLanguage(lang) {
      const source = isTranslated && currentTranslation 
        ? currentTranslation.original 
        : getVisibleOutputText();
      
      if (!source) return;

      // Store original if first translation
      if (!currentTranslation) {
        currentTranslation = { original: source };
      }

      closeTranslateMenu();
      
      // Show loading state
      const loadingText = "Traduciendo...";
      const previousText = output.textContent;
      setOutputHtml(escapeHtml(loadingText));

      try {
        const r = await fetch("/api/translate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: source, target: lang })
        });
        const data = await r.json().catch(() => ({ translation: "" }));
        const translated = (data.translation || "").trim();
        
        if (translated) {
          currentTranslation.text = translated;
          currentTranslation.lang = lang;
          setOutputHtml(escapeHtml(translated));
          isTranslated = true;
          showTranslateBanner(lang);
          outputCharCount.textContent = `${translated.length} caracteres`;
        } else {
          setOutputHtml(escapeHtml(previousText));
          alert("No se pudo traducir. Intenta nuevamente.");
        }
      } catch {
        setOutputHtml(escapeHtml(previousText));
        alert("No se pudo traducir. Intenta nuevamente.");
      }
    }

    outputMenuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if (outputMenu.hidden) openOutputMenu();
      else closeOutputMenu();
    });

    outputMenu.addEventListener("click", (e) => e.stopPropagation());

    translateBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if (translateMenu.hidden) openTranslateMenu();
      else closeTranslateMenu();
    });

    translateMenu.addEventListener("click", (e) => e.stopPropagation());

    translateMenu.querySelectorAll("button[data-lang]").forEach(btn => {
      btn.addEventListener("click", () => {
        const lang = btn.dataset.lang;
        translateToLanguage(lang);
      });
    });

    translateBannerClose.addEventListener("click", () => {
      restoreOriginalText();
    });

    document.addEventListener("click", (event) => {
      if (synonymPopover) {
        if (synonymPopover.contains(event.target)) return;
        if (event.target.closest(".syn-word") === synonymAnchor) return;
        closeSynonymPopover();
      }
      if (!outputMenu.hidden) closeOutputMenu();
      if (!translateMenu.hidden) closeTranslateMenu();
    });

    document.addEventListener("keydown", (event) => {
      if (event.key !== "Escape") return;
      closeSynonymPopover();
      if (!outputMenu.hidden) closeOutputMenu();
      if (!translateMenu.hidden) closeTranslateMenu();
      if (!historyModal.hidden) closeHistoryModal();
    });

    menuDownloadPdf.addEventListener("click", () => {
      closeOutputMenu();
      downloadPdf();
    });

    menuDownloadDocx.addEventListener("click", () => {
      closeOutputMenu();
      downloadDocx().catch(() => {});
    });

    output.addEventListener("input", () => {
      if (isProgrammaticUpdate || !currentResultText) return;

      isManualEdited = true;
      diffViewEnabled = false;
      disableDiffButton("Editado manualmente");
      outputCharCount.textContent = `${output.textContent.length} caracteres`;
      similarityText.textContent = "";
      
      // Reset translation state on manual edit
      currentTranslation = null;
      isTranslated = false;
      hideTranslateBanner();
      
      updateExportButtons();
    });

    btn.addEventListener("click", async () => {
      const text = input.value.trim();
      if (!text) return;

      const STREAM_TIMEOUT_MS = 25000;
      const controller = new AbortController();
      let reader;
      let timeoutId;
      let streamTimedOut = false;

      btn.disabled = true;
      setParaphraseLabel(true);
      outputCharCount.textContent = "";
      similarityText.textContent = "";

      disableDiffButton("");
      isManualEdited = false;
      hasReceivedFirstChunk = false;
      currentOriginalText = text;
      currentResultText = "";
      currentDiff = null;
      
      // Reset translation state
      currentTranslation = null;
      isTranslated = false;
      hideTranslateBanner();
      
      updateExportButtons();
      showSkeleton();

      try {
        timeoutId = setTimeout(() => {
          streamTimedOut = true;
          controller.abort();
          if (reader) {
            reader.cancel("timeout").catch(() => {});
          }
        }, STREAM_TIMEOUT_MS);

        const res = await fetch("/api/summary", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            text,
            mode: currentMode
          }),
          signal: controller.signal
        });

        if (!res.ok || !res.body) {
          if (res.status === 413) {
            throw new Error("El texto es demasiado largo, intenta con un p√°rrafo m√°s corto.");
          }
          throw new Error("No se pudo generar el texto. Intenta nuevamente.");
        }

        reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let streamDone = false;

        while (!streamDone) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const events = buffer.split("\n\n");
          buffer = events.pop() || "";

          for (const eventBlock of events) {
            const line = eventBlock
              .split("\n")
              .find(lineItem => lineItem.startsWith("data:"));

            if (!line) continue;

            const payloadText = line.replace(/^data:\s*/, "");
            if (!payloadText || payloadText === "[DONE]") continue;

            const payload = JSON.parse(payloadText);

            if (payload.type === "chunk" && payload.text) {
              currentResultText += payload.text;

              if (!hasReceivedFirstChunk) {
                hasReceivedFirstChunk = true;
              }

              setOutputHtml(escapeHtml(currentResultText));
              outputCharCount.textContent = `${currentResultText.length} caracteres`;
              updateExportButtons();
            }

            if (payload.type === "error") {
              throw new Error(payload.message || "No se pudo generar el texto. Intenta nuevamente.");
            }

            if (payload.type === "done") {
              streamDone = true;
              break;
            }
          }
        }

        if (streamTimedOut) {
          throw new Error("La generaci√≥n tard√≥ demasiado. Intenta nuevamente.");
        }

        if (!currentResultText.trim()) {
          throw new Error("No se pudo generar el texto. Intenta nuevamente.");
        }

        currentDiff = buildDiffData(currentOriginalText, currentResultText);
        diffViewEnabled = false;
        applyOutputView();

        if (currentDiff.diffDisabled) {
          disableDiffButton("Cambios no disponibles por longitud del texto");
        } else {
          enableDiffButton("");
        }

        const similarity = currentDiff.totalCount
          ? Math.round(100 - (currentDiff.addedCount / currentDiff.totalCount) * 100)
          : 100;
        similarityText.textContent = getSimilarityLabel(similarity);

        saveHistoryEntry({
          original: currentOriginalText,
          result: currentResultText,
          mode: currentMode,
          timestamp: Date.now()
        });
      } catch (err) {
        const isTooLongError = err?.message === "El texto es demasiado largo, intenta con un p√°rrafo m√°s corto.";
        const isTimeoutError = streamTimedOut || err?.name === "AbortError";
        const message = isTooLongError
          ? err.message
          : isTimeoutError
            ? "La generaci√≥n tard√≥ demasiado. Reintenta en unos segundos."
            : "No se pudo generar el texto. Intenta nuevamente.";

        setOutputHtml(escapeHtml(message));
        outputCharCount.textContent = "";
        similarityText.textContent = "";
      } finally {
        clearTimeout(timeoutId);
        if (reader) {
          reader.cancel().catch(() => {});
        }
        btn.disabled = false;
        setParaphraseLabel(false);
        updateExportButtons();
      }
    });

    copyBtn.addEventListener("click", async () => {
      const text = output.textContent.trim();
      if (!text) return;

      try {
        await navigator.clipboard.writeText(text);
        copyBtn.textContent = "Copiado";
        setTimeout(() => {
          copyBtn.textContent = "Copiar";
        }, 1200);
      } catch {
        copyBtn.textContent = "Error";
        setTimeout(() => {
          copyBtn.textContent = "Copiar";
        }, 1200);
      }
    });

    copyInputBtn.addEventListener("click", async () => {
      const text = input.value;
      if (!text) return;

      try {
        await navigator.clipboard.writeText(text);
        copyInputBtn.textContent = "Copiado";
        setTimeout(() => {
          copyInputBtn.textContent = "Copiar";
        }, 1200);
      } catch {
        copyInputBtn.textContent = "Error";
        setTimeout(() => {
          copyInputBtn.textContent = "Copiar";
        }, 1200);
      }
    });

    // ============================================
    // CORRECTION MODE FUNCTIONALITY
    // ============================================
    
    let corrections = [];
    let correctionIdCounter = 0;
    let activeErrorId = null;
    const inputTextCorrectable = document.getElementById('inputTextCorrectable');
    
    // Detectar errores usando la API de LanguageTool
    async function detectErrorsAPI(text) {
      if (!text || text.trim().length === 0) return [];
      
      try {
        const response = await fetch('/api/correct', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            text: text,
            language: 'es'
          })
        });

        if (!response.ok) {
          console.error('Error en la API de correcci√≥n:', response.status);
          return [];
        }

        const data = await response.json();
        
        // Mapear los errores de la API al formato interno
        return (data.errors || []).map(error => ({
          id: correctionIdCounter++,
          type: error.type || 'grammar',
          errorText: error.errorText,
          suggestion: error.suggestion,
          start: error.start,
          end: error.end,
          message: error.message || 'Error detectado',
          allSuggestions: error.allSuggestions || [error.suggestion],
          ignored: false,
          accepted: false
        }));
      } catch (error) {
        console.error('Error al detectar errores:', error);
        return [];
      }
    }
    
    // Funci√≥n legacy para compatibilidad (ahora solo para fallback)
    function detectErrors(text) {
      if (!text) return [];
      
      const errors = [];
      const textLower = text.toLowerCase();
      
      // Diccionario de errores comunes (fallback)
      const spellingErrors = {
        'exsitosa': 'exitosa',
        'exito': '√©xito',
        'abeses': 'a veces',
        'aver': 'a ver',
        'haci': 'as√≠',
        'porke': 'porque',
        'ke': 'que',
        'kiero': 'quiero',
        'tambien': 'tambi√©n',
        'mas': 'm√°s',
        'raul': 'Ra√∫l'
      };
      
      // Buscar palabras con errores
      const wordRegex = /\b[\w√°√©√≠√≥√∫√±√º]+\b/gi;
      let match;
      
      while ((match = wordRegex.exec(text)) !== null) {
        const word = match[0];
        const wordLower = word.toLowerCase();
        
        if (spellingErrors[wordLower]) {
          errors.push({
            id: correctionIdCounter++,
            type: 'spelling',
            errorText: word,
            suggestion: spellingErrors[wordLower],
            start: match.index,
            end: match.index + word.length,
            message: 'Posible error ortogr√°fico'
          });
        }
      }
      
      // Detectar errores de puntuaci√≥n (espacios antes de puntuaci√≥n)
      const punctuationRegex = /\s+([.,;:!?])/g;
      while ((match = punctuationRegex.exec(text)) !== null) {
        errors.push({
          id: correctionIdCounter++,
          type: 'punctuation',
          errorText: match[0],
          suggestion: match[1],
          start: match.index,
          end: match.index + match[0].length,
          message: 'No debe haber espacio antes de la puntuaci√≥n'
        });
      }
      
      return errors;
    }
    
    // Obtener texto plano del div contenteditable
    function getPlainText(element) {
      return element.textContent || '';
    }
    
    // Establecer texto con marcado de errores
    function setTextWithErrors(text, errors) {
      if (!text) {
        inputTextCorrectable.innerHTML = '';
        return;
      }
      
      if (errors.length === 0) {
        inputTextCorrectable.textContent = text;
        return;
      }
      
      // Guardar posici√≥n del cursor ANTES de modificar
      const selection = window.getSelection();
      let cursorNode = null;
      let cursorOffset = 0;
      let savedRange = null;
      
      if (selection.rangeCount > 0) {
        savedRange = selection.getRangeAt(0).cloneRange();
        cursorNode = savedRange.startContainer;
        cursorOffset = savedRange.startOffset;
      }
      
      // Calcular posici√≥n absoluta del cursor en el texto
      let absoluteCursorPos = 0;
      if (cursorNode) {
        let node = inputTextCorrectable.firstChild;
        let found = false;
        
        while (node && !found) {
          if (node === cursorNode) {
            absoluteCursorPos += cursorOffset;
            found = true;
          } else if (node.nodeType === Node.TEXT_NODE) {
            absoluteCursorPos += node.textContent.length;
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.contains(cursorNode)) {
              absoluteCursorPos += getTextBeforeNode(node, cursorNode, cursorOffset);
              found = true;
            } else {
              absoluteCursorPos += node.textContent.length;
            }
          }
          node = node.nextSibling;
        }
      }
      
      // Dividir texto en l√≠neas
      const lines = text.split('\n');
      let globalPosition = 0;
      
      // Ordenar errores por posici√≥n
      const sortedErrors = [...errors].sort((a, b) => a.start - b.start);
      
      // Funci√≥n para encontrar errores en un rango
      const findErrorsInRange = (start, end) => {
        return sortedErrors.filter(error => {
          return (error.start >= start && error.start < end) ||
                 (error.end > start && error.end <= end) ||
                 (error.start < start && error.end > end);
        });
      };
      
      // Construir HTML l√≠nea por l√≠nea
      let html = '';
      
      lines.forEach((line, lineIndex) => {
        const lineStart = globalPosition;
        const lineEnd = globalPosition + line.length;
        
        // Encontrar errores en esta l√≠nea
        const errorsInLine = findErrorsInRange(lineStart, lineEnd);
        
        // Determinar si esta l√≠nea tiene el error activo
        const hasActiveError = errorsInLine.some(error => error.id === activeErrorId);
        
        // Clase para la l√≠nea
        const lineClass = hasActiveError ? 'text-line active-line' : 'text-line';
        
        // Construir contenido de la l√≠nea
        let lineHtml = '';
        let lastIndex = lineStart;
        
        errorsInLine.forEach(error => {
          // Texto antes del error (dentro de la l√≠nea)
          if (error.start > lastIndex) {
            lineHtml += escapeHtml(text.substring(lastIndex, error.start));
          }
          
          // Error marcado
          const errorClass = error.type === 'spelling' 
            ? 'correction-error correction-error-spelling' 
            : 'correction-error correction-error-punctuation';
          
          const activeClass = activeErrorId === error.id ? ' active' : '';
          
          lineHtml += `<span class="${errorClass}${activeClass}" data-error-id="${error.id}">${escapeHtml(error.errorText)}</span>`;
          
          lastIndex = error.end;
        });
        
        // Texto restante de la l√≠nea
        if (lastIndex < lineEnd) {
          lineHtml += escapeHtml(text.substring(lastIndex, lineEnd));
        }
        
        // Si la l√≠nea est√° vac√≠a, agregar un espacio para mantener la altura
        if (!lineHtml) {
          lineHtml = '<br>';
        }
        
        html += `<div class="${lineClass}">${lineHtml}</div>`;
        
        globalPosition = lineEnd + 1; // +1 por el \n
      });
      
      inputTextCorrectable.innerHTML = html;
      
      // Restaurar cursor
      if (absoluteCursorPos > 0) {
        try {
          const range = document.createRange();
          const sel = window.getSelection();
          
          let currentPos = 0;
          let targetNode = null;
          let targetOffset = 0;
          
          const walkNodes = (node) => {
            if (node.nodeType === Node.TEXT_NODE) {
              const nodeLength = node.textContent.length;
              if (currentPos + nodeLength >= absoluteCursorPos) {
                targetNode = node;
                targetOffset = absoluteCursorPos - currentPos;
                return true;
              }
              currentPos += nodeLength;
            } else if (node.nodeType === Node.ELEMENT_NODE) {
              for (let child of node.childNodes) {
                if (walkNodes(child)) return true;
              }
            }
            return false;
          };
          
          walkNodes(inputTextCorrectable);
          
          if (targetNode) {
            range.setStart(targetNode, Math.min(targetOffset, targetNode.textContent.length));
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
          }
        } catch (e) {
          console.error('Error restaurando cursor:', e);
        }
      }
      
      // Agregar event listeners a los errores
      inputTextCorrectable.querySelectorAll('.correction-error').forEach(errorSpan => {
        errorSpan.addEventListener('click', (e) => {
          e.preventDefault();
          const errorId = parseInt(errorSpan.dataset.errorId);
          highlightError(errorId);
        });
      });
    }
    
    // Funci√≥n auxiliar para calcular posici√≥n de texto antes de un nodo
    function getTextBeforeNode(parent, targetNode, offset) {
      let length = 0;
      
      const walk = (node) => {
        if (node === targetNode) {
          length += offset;
          return true;
        }
        
        if (node.nodeType === Node.TEXT_NODE) {
          length += node.textContent.length;
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          for (let child of node.childNodes) {
            if (walk(child)) return true;
          }
        }
        return false;
      };
      
      for (let child of parent.childNodes) {
        if (walk(child)) break;
      }
      
      return length;
    }
    
    // Detectar y mostrar correcciones (ahora async)
    async function checkCorrections() {
      const text = getPlainText(inputTextCorrectable);
      
      // NO mostrar "Analizando texto..." - llamar directamente a la API
      
      // Llamar a la API para detectar errores
      const detectedErrors = await detectErrorsAPI(text);
      
      // Mantener los estados de ignored/accepted de errores previos
      detectedErrors.forEach(newError => {
        const existingError = corrections.find(
          e => e.start === newError.start && e.end === newError.end && e.errorText === newError.errorText
        );
        if (existingError) {
          newError.ignored = existingError.ignored;
          newError.accepted = existingError.accepted;
        }
      });
      
      corrections = detectedErrors;
      renderCorrectionsList();
      setTextWithErrors(text, corrections.filter(c => !c.ignored && !c.accepted));
      
      // Actualizar contador de caracteres
      const inputCharCount = document.getElementById('inputCharCount');
      if (inputCharCount) {
        inputCharCount.textContent = `${text.length} caracteres`;
      }
    }
    
    // Renderizar lista de correcciones
    function renderCorrectionsList() {
      const correctionList = document.getElementById('correctionList');
      const correctionCount = document.getElementById('correctionCount');
      
      if (!correctionList || !correctionCount) return;
      
      const activeCorrections = corrections.filter(c => !c.ignored && !c.accepted);
      correctionCount.textContent = activeCorrections.length;
      correctionCount.setAttribute('data-count', activeCorrections.length);
      
      // Si no hay texto en el input, no mostrar nada
      const currentText = getPlainText(inputTextCorrectable);
      if (!currentText || currentText.trim().length === 0) {
        correctionList.innerHTML = '';
        correctionCount.textContent = '0';
        correctionCount.setAttribute('data-count', '0');
        correctionCount.style.display = 'none';
        return;
      }
      
      // Detectar inconsistencias de tono (formal/informal)
      detectToneInconsistency(currentText);
      
      // Si hay texto pero no errores
      if (activeCorrections.length === 0) {
        correctionList.innerHTML = `
          <div class="no-corrections">
            <div class="no-corrections-icon">‚úì</div>
            <div><strong>No se encontraron errores</strong></div>
          </div>
        `;
        correctionCount.style.display = 'inline-block';
        return;
      }
      
      // Si hay errores
      correctionCount.style.display = 'inline-block';
      
      correctionList.innerHTML = activeCorrections.map(error => {
        // Determinar el label del tipo de error
        let typeLabel = 'Gram√°tica';
        if (error.type === 'spelling') {
          typeLabel = 'Ortograf√≠a';
        } else if (error.type === 'punctuation') {
          typeLabel = 'Puntuaci√≥n';
        }
        
        const iconClass = error.type === 'spelling' 
          ? 'correction-icon-spelling' 
          : 'correction-icon-punctuation';
        const isActive = activeErrorId === error.id;
        
        // Generar HTML para todas las sugerencias
        const allSuggestions = error.allSuggestions || [error.suggestion];
        const suggestionsHTML = allSuggestions
          .filter(s => s && s.trim().length > 0)
          .slice(0, 3)
          .map((suggestion, idx) => `
            <div class="correction-suggestion" data-action="apply-suggestion" data-suggestion="${escapeHtml(suggestion)}">
              ${escapeHtml(suggestion)}
            </div>
          `).join('');
        
        // Smart Replace: obtener sin√≥nimos contextuales (minimalista)
        const smartReplaceHTML = isActive ? `
          <div class="smart-replace" data-error-id="${error.id}">
            <div class="smart-replace-trigger" onclick="loadSmartReplace(${error.id}, '${escapeHtml(error.errorText)}')">
              Sin√≥nimos...
            </div>
            <div class="smart-replace-results" id="smartReplace${error.id}"></div>
          </div>
        ` : '';
        
        // Traductor minimalista (solo iconos de banderas)
        const translationHTML = isActive ? `
          <div class="translation-bar">
            <span class="translation-trigger" onclick="translate(${error.id}, '${escapeHtml(error.suggestion)}', 'en')" title="English">EN</span>
            <span class="translation-trigger" onclick="translate(${error.id}, '${escapeHtml(error.suggestion)}', 'fr')" title="Fran√ßais">FR</span>
            <span class="translation-trigger" onclick="translate(${error.id}, '${escapeHtml(error.suggestion)}', 'de')" title="Deutsch">DE</span>
            <span class="translation-trigger" onclick="translate(${error.id}, '${escapeHtml(error.suggestion)}', 'pt')" title="Portugu√™s">PT</span>
            <div class="translation-result" id="translation${error.id}"></div>
          </div>
        ` : '';
        
        return `
          <div class="correction-item ${isActive ? 'active' : ''}" data-error-id="${error.id}">
            <div class="correction-item-header">
              <div class="correction-icon ${iconClass}"></div>
              <div class="correction-item-content">
                <!-- Texto compacto (solo visible cuando NO est√° activo) -->
                <div class="correction-compact-text">
                  <span style="color: #5f6368; font-weight: 500;">${escapeHtml(error.errorText)}</span>
                  <span style="color: #d0d0d0;">‚Üí</span>
                  <span style="color: #202124; font-weight: 500;">${escapeHtml(error.suggestion)}</span>
                </div>
                
                <!-- Contenido expandido (solo visible cuando est√° activo) -->
                <div class="correction-type">${typeLabel}</div>
                <div class="correction-error-text">
                  ${escapeHtml(error.message)}
                </div>
                ${suggestionsHTML}
                ${smartReplaceHTML}
                ${translationHTML}
                <div class="correction-actions">
                  <button class="correction-btn" data-action="ignore">
                    Ignorar
                  </button>
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');
      
      // Agregar event listeners
      correctionList.querySelectorAll('.correction-item').forEach(item => {
        const errorId = parseInt(item.dataset.errorId);
        
        item.addEventListener('click', (e) => {
          if (!e.target.closest('[data-action]')) {
            toggleErrorHighlight(errorId);
          }
        });
        
        // Event listener para cada sugerencia
        item.querySelectorAll('[data-action="apply-suggestion"]').forEach(suggestionBtn => {
          suggestionBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const suggestion = suggestionBtn.dataset.suggestion;
            applySuggestion(errorId, suggestion);
          });
        });
        
        const ignoreBtn = item.querySelector('[data-action="ignore"]');
        if (ignoreBtn) {
          ignoreBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            ignoreError(errorId);
          });
        }
      });
    }
    
    // Toggle para expandir/colapsar error (como LanguageTool)
    function toggleErrorHighlight(errorId) {
      // Si ya est√° activo, colapsarlo
      if (activeErrorId === errorId) {
        activeErrorId = null;
        
        // Remover todas las clases active
        document.querySelectorAll('.correction-item').forEach(item => {
          item.classList.remove('active');
        });
        
        inputTextCorrectable.querySelectorAll('.correction-error').forEach(span => {
          span.classList.remove('active');
        });
        
        // Remover efecto de texto atenuado
        inputTextCorrectable.classList.remove('dimmed-text');
        
      } else {
        // Cerrar cualquier tarjeta previamente abierta
        document.querySelectorAll('.correction-item').forEach(item => {
          item.classList.remove('active');
        });
        
        inputTextCorrectable.querySelectorAll('.correction-error').forEach(span => {
          span.classList.remove('active');
        });
        
        // Expandir este error
        activeErrorId = errorId;
        
        // Actualizar clases en la lista
        document.querySelectorAll('.correction-item').forEach(item => {
          if (parseInt(item.dataset.errorId) === errorId) {
            item.classList.add('active');
          }
        });
        
        // Actualizar clases en el texto
        inputTextCorrectable.querySelectorAll('.correction-error').forEach(span => {
          if (parseInt(span.dataset.errorId) === errorId) {
            span.classList.add('active');
          }
        });
        
        // Aplicar efecto de texto atenuado (como LanguageTool)
        inputTextCorrectable.classList.add('dimmed-text');
        
        // Scroll al error en el texto
        const errorSpan = inputTextCorrectable.querySelector(`[data-error-id="${errorId}"]`);
        if (errorSpan) {
          errorSpan.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // Scroll a la tarjeta en la lista
        const errorCard = document.querySelector(`.correction-item[data-error-id="${errorId}"]`);
        if (errorCard) {
          errorCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    }
    
    // Resaltar un error espec√≠fico (mantener para compatibilidad)
    function highlightError(errorId) {
      toggleErrorHighlight(errorId);
    }
    
    // Aplicar sugerencia
    function applySuggestion(errorId, customSuggestion = null) {
      const error = corrections.find(e => e.id === errorId);
      if (!error) return;
      
      const text = getPlainText(inputTextCorrectable);
      const before = text.substring(0, error.start);
      const after = text.substring(error.end);
      
      // Usar la sugerencia personalizada o la sugerencia por defecto
      const suggestionToApply = customSuggestion || error.suggestion;
      const newText = before + suggestionToApply + after;
      
      // Actualizar posiciones de otros errores
      const diff = suggestionToApply.length - error.errorText.length;
      corrections.forEach(e => {
        if (e.start > error.start) {
          e.start += diff;
          e.end += diff;
        }
      });
      
      // Marcar como aceptado
      error.accepted = true;
      
      // Encontrar el siguiente error activo
      const remainingErrors = corrections.filter(c => !c.ignored && !c.accepted);
      const currentIndex = remainingErrors.findIndex(e => e.id === errorId);
      const nextError = remainingErrors[currentIndex]; // El siguiente ya que este se acaba de aceptar
      
      // Actualizar texto
      inputTextCorrectable.textContent = newText;
      
      // Re-chequear y luego abrir siguiente
      setTimeout(async () => {
        await checkCorrections();
        
        // Abrir autom√°ticamente la siguiente tarjeta
        const updatedRemainingErrors = corrections.filter(c => !c.ignored && !c.accepted);
        if (updatedRemainingErrors.length > 0) {
          // Abrir la primera tarjeta de la lista actualizada
          toggleErrorHighlight(updatedRemainingErrors[0].id);
        } else {
          // No hay m√°s errores, cerrar todo
          activeErrorId = null;
          inputTextCorrectable.classList.remove('dimmed-text');
        }
      }, 150);
    }
    
    // Ignorar error
    function ignoreError(errorId) {
      const error = corrections.find(e => e.id === errorId);
      if (!error) return;
      
      error.ignored = true;
      
      const text = getPlainText(inputTextCorrectable);
      renderCorrectionsList();
      setTextWithErrors(text, corrections.filter(c => !c.ignored && !c.accepted));
      
      // Encontrar y abrir autom√°ticamente la siguiente tarjeta
      const remainingErrors = corrections.filter(c => !c.ignored && !c.accepted);
      if (remainingErrors.length > 0) {
        // Abrir la primera tarjeta de la lista actualizada
        setTimeout(() => {
          toggleErrorHighlight(remainingErrors[0].id);
        }, 100);
      } else {
        // No hay m√°s errores, cerrar todo
        activeErrorId = null;
        inputTextCorrectable.classList.remove('dimmed-text');
      }
    }
    
    // ============================================
    // FEATURE 1: Detector de Tono Contextual
    // ============================================
    function detectToneInconsistency(text) {
      const toneDetector = document.getElementById('toneDetector');
      const toneMessage = document.getElementById('toneMessage');
      
      if (!toneDetector || !toneMessage) return;
      
      // Patrones formales e informales
      const formalPatterns = [
        /\bEstimado\b/i, /\bAtentamente\b/i, /\busted\b/i, /\bse√±or\b/i,
        /\bse√±ora\b/i, /\bperm√≠tame\b/i, /\ble informo\b/i, /\ble agradezco\b/i
      ];
      
      const informalPatterns = [
        /\bt√∫\b/i, /\bhola\b(?! se√±or)/i, /\bche\b/i, /\bt√≠o\b/i,
        /\bchava\b/i, /\bwey\b/i, /\bboludo\b/i, /\bqu√© tal\b/i
      ];
      
      const hasFormal = formalPatterns.some(pattern => pattern.test(text));
      const hasInformal = informalPatterns.some(pattern => pattern.test(text));
      
      if (hasFormal && hasInformal) {
        toneMessage.textContent = 'Detect√© lenguaje formal e informal mezclado. ¬øPrefieres unificar el tono?';
        toneDetector.style.display = 'block';
      } else {
        toneDetector.style.display = 'none';
      }
    }
    
    // Unificar tono (formal/informal)
    function unifyTone(tone) {
      const text = getPlainText(inputTextCorrectable);
      let newText = text;
      
      if (tone === 'formal') {
        // Convertir a formal
        newText = newText
          .replace(/\bt√∫\b/gi, 'usted')
          .replace(/\btienes\b/gi, 'tiene')
          .replace(/\beres\b/gi, 'es')
          .replace(/\btu\b/gi, 'su')
          .replace(/\bte\b/gi, 'le')
          .replace(/\bhola\b/gi, 'Estimado')
          .replace(/\bgracias\b/gi, 'Le agradezco');
      } else {
        // Convertir a informal
        newText = newText
          .replace(/\busted\b/gi, 't√∫')
          .replace(/\bEstimado\b/gi, 'Hola')
          .replace(/\bAtentamente\b/gi, 'Saludos')
          .replace(/\ble informo\b/gi, 'te informo')
          .replace(/\ble agradezco\b/gi, 'te agradezco');
      }
      
      inputTextCorrectable.textContent = newText;
      document.getElementById('toneDetector').style.display = 'none';
      
      // Re-analizar
      setTimeout(() => checkCorrections(), 100);
    }
    
    // ============================================
    // FEATURE 2: Corrector Regional
    // ============================================
    const REGIONAL_VARIANTS = {
      'carro': { 'es': 'coche', 'ar': 'auto', 'mx': 'carro', 'co': 'carro', 'cl': 'auto' },
      'auto': { 'es': 'coche', 'ar': 'auto', 'mx': 'carro', 'co': 'carro', 'cl': 'auto' },
      'coche': { 'es': 'coche', 'ar': 'auto', 'mx': 'carro', 'co': 'carro', 'cl': 'auto' },
      'computadora': { 'es': 'ordenador', 'ar': 'computadora', 'mx': 'computadora', 'co': 'computador', 'cl': 'computador' },
      'ordenador': { 'es': 'ordenador', 'ar': 'computadora', 'mx': 'computadora', 'co': 'computador', 'cl': 'computador' },
      'celular': { 'es': 'm√≥vil', 'ar': 'celular', 'mx': 'celular', 'co': 'celular', 'cl': 'celular' },
      'm√≥vil': { 'es': 'm√≥vil', 'ar': 'celular', 'mx': 'celular', 'co': 'celular', 'cl': 'celular' },
      'estacionamiento': { 'es': 'aparcamiento', 'ar': 'estacionamiento', 'mx': 'estacionamiento', 'co': 'parqueadero', 'cl': 'estacionamiento' },
      'apartamento': { 'es': 'piso', 'ar': 'departamento', 'mx': 'departamento', 'co': 'apartamento', 'cl': 'departamento' },
      'rentar': { 'es': 'alquilar', 'ar': 'alquilar', 'mx': 'rentar', 'co': 'arrendar', 'cl': 'arrendar' }
    };
    
    function applyRegionalVariant(text, region) {
      if (region === 'neutral') return text;
      
      let newText = text;
      for (const [word, variants] of Object.entries(REGIONAL_VARIANTS)) {
        if (variants[region]) {
          const regex = new RegExp('\\b' + word + '\\b', 'gi');
          newText = newText.replace(regex, variants[region]);
        }
      }
      return newText;
    }
    
    // Event listener para el selector regional
    document.getElementById('regionSelector')?.addEventListener('change', function(e) {
      const region = e.target.value;
      const text = getPlainText(inputTextCorrectable);
      const newText = applyRegionalVariant(text, region);
      
      if (newText !== text) {
        inputTextCorrectable.textContent = newText;
        setTimeout(() => checkCorrections(), 100);
      }
    });
    
    // ============================================
    // FEATURE 3: Smart Replace (Sin√≥nimos)
    // ============================================
    async function loadSmartReplace(errorId, word) {
      const container = document.getElementById(`smartReplace${errorId}`);
      if (!container) return;
      
      // Mostrar loading
      container.innerHTML = '<span style="font-size: 11px; color: #999;">Cargando...</span>';
      
      try {
        // Llamar a API de sin√≥nimos
        const response = await fetch('/api/synonyms.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ word })
        });
        
        const data = await response.json();
        const synonyms = data.synonyms || [];
        
        if (synonyms.length === 0) {
          container.innerHTML = '<span style="font-size: 11px; color: #999;">No hay sin√≥nimos</span>';
          return;
        }
        
        // Renderizar sin√≥nimos como chips minimalistas
        container.innerHTML = synonyms.slice(0, 5).map(syn => 
          `<span class="synonym-chip" onclick="replaceSynonym(${errorId}, '${escapeHtml(syn)}')">${escapeHtml(syn)}</span>`
        ).join('');
        
      } catch (error) {
        container.innerHTML = '<span style="font-size: 11px; color: #999;">Error al cargar</span>';
      }
    }
    
    function replaceSynonym(errorId, synonym) {
      applySuggestion(errorId, synonym);
    }
    
    // ============================================
    // FEATURE 4: Traductor Integrado
    // ============================================
    async function translate(errorId, text, targetLang) {
      const resultContainer = document.getElementById(`translation${errorId}`);
      if (!resultContainer) return;
      
      // Mostrar loading
      resultContainer.textContent = 'Traduciendo...';
      resultContainer.classList.add('visible');
      
      try {
        // Llamar a API de traducci√≥n
        const response = await fetch('/api/translate.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: text,
            source_lang: 'es',
            target_lang: targetLang
          })
        });
        
        const data = await response.json();
        const translation = data.translatedText || data.translation || text;
        
        // Mostrar traducci√≥n
        resultContainer.textContent = translation;
        
      } catch (error) {
        resultContainer.textContent = 'Error al traducir';
        setTimeout(() => {
          resultContainer.classList.remove('visible');
        }, 2000);
      }
    }
    
    // Event listeners para botones de tono
    document.querySelectorAll('.tone-btn').forEach(btn => {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        const action = this.getAttribute('data-action');
        
        if (action === 'formal' || action === 'informal') {
          unifyTone(action);
        } else if (action === 'dismiss') {
          document.getElementById('toneDetector').style.display = 'none';
        }
      });
    });
    
    // Toggle entre modo normal y modo correcci√≥n
    function toggleCorrectionMode(isCorrectionMode) {
      const correctionPanel = document.getElementById('correctionPanel');
      
      if (isCorrectionMode) {
        // Copiar texto del textarea al div editable
        const text = input.value;
        inputTextCorrectable.textContent = text;
        input.style.display = 'none';
        inputTextCorrectable.style.display = 'block';
        
        // Mostrar panel de correcciones
        if (correctionPanel) {
          correctionPanel.style.display = 'flex';
        }
        
        // Iniciar chequeo
        checkCorrections();
      } else {
        // Copiar texto del div editable al textarea
        const text = getPlainText(inputTextCorrectable);
        input.value = text;
        inputTextCorrectable.style.display = 'none';
        input.style.display = 'block';
        
        // Ocultar panel de correcciones
        if (correctionPanel) {
          correctionPanel.style.display = 'none';
        }
        
        // Limpiar correcciones
        corrections = [];
        activeErrorId = null;
        inputTextCorrectable.classList.remove('dimmed-text');
      }
    }
    
    // Event listener para cambios en el texto editable
    let correctionTimeout;
    inputTextCorrectable.addEventListener('input', () => {
      clearTimeout(correctionTimeout);
      correctionTimeout = setTimeout(() => {
        if (currentMode === 'correccion') {
          checkCorrections();
        }
      }, 800);
    });
    
    // Prevenir que se pegue HTML formateado
    inputTextCorrectable.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text/plain');
      document.execCommand('insertText', false, text);
    });
    
    // Inicializar modo correcci√≥n si es el modo activo
    renderModeControls();
    setActiveMode(currentMode);
    if (currentMode === 'correccion') {
      const editorPanel = document.getElementById('editorPanel');
      if (editorPanel) {
        editorPanel.classList.add('correction-mode');
        toggleCorrectionMode(true);
      }
    } else {
      // Si no es modo correcci√≥n, ocultar el panel
      const correctionPanel = document.getElementById('correctionPanel');
      if (correctionPanel) {
        correctionPanel.style.display = 'none';
      }
    }

  </script>


</body>
</html>
